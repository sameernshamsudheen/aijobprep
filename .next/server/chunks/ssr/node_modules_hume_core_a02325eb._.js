module.exports = {

"[project]/node_modules/hume/core/json.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toJson = void 0;
exports.fromJson = fromJson;
/**
 * Serialize a value to JSON
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @returns JSON string
 */ const toJson = (value, replacer, space)=>{
    return JSON.stringify(value, replacer, space);
};
exports.toJson = toJson;
/**
 * Parse JSON string to object, array, or other type
 * @param text A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
 * @returns Parsed object, array, or other type
 */ function fromJson(text, reviver) {
    return JSON.parse(text, reviver);
}
}}),
"[project]/node_modules/hume/core/fetcher/Headers.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Headers = void 0;
let Headers;
if (typeof globalThis.Headers !== "undefined") {
    exports.Headers = Headers = globalThis.Headers;
} else {
    exports.Headers = Headers = class Headers {
        constructor(init){
            this.headers = new Map();
            if (init) {
                if (init instanceof Headers) {
                    init.forEach((value, key)=>this.append(key, value));
                } else if (Array.isArray(init)) {
                    for (const [key, value] of init){
                        if (typeof key === "string" && typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Each header entry must be a [string, string] tuple");
                        }
                    }
                } else {
                    for (const [key, value] of Object.entries(init)){
                        if (typeof value === "string") {
                            this.append(key, value);
                        } else {
                            throw new TypeError("Header values must be strings");
                        }
                    }
                }
            }
        }
        append(name, value) {
            const key = name.toLowerCase();
            const existing = this.headers.get(key) || [];
            this.headers.set(key, [
                ...existing,
                value
            ]);
        }
        delete(name) {
            const key = name.toLowerCase();
            this.headers.delete(key);
        }
        get(name) {
            const key = name.toLowerCase();
            const values = this.headers.get(key);
            return values ? values.join(", ") : null;
        }
        has(name) {
            const key = name.toLowerCase();
            return this.headers.has(key);
        }
        set(name, value) {
            const key = name.toLowerCase();
            this.headers.set(key, [
                value
            ]);
        }
        forEach(callbackfn, thisArg) {
            const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
            this.headers.forEach((values, key)=>boundCallback(values.join(", "), key, this));
        }
        getSetCookie() {
            return this.headers.get("set-cookie") || [];
        }
        *entries() {
            for (const [key, values] of this.headers.entries()){
                yield [
                    key,
                    values.join(", ")
                ];
            }
        }
        *keys() {
            yield* this.headers.keys();
        }
        *values() {
            for (const values of this.headers.values()){
                yield values.join(", ");
            }
        }
        [Symbol.iterator]() {
            return this.entries();
        }
    };
}
}}),
"[project]/node_modules/hume/core/fetcher/RawResponse.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknownRawResponse = exports.abortRawResponse = void 0;
exports.toRawResponse = toRawResponse;
const Headers_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/Headers.js [app-rsc] (ecmascript)");
/**
 * A raw response indicating that the request was aborted.
 */ exports.abortRawResponse = {
    headers: new Headers_1.Headers(),
    redirected: false,
    status: 499,
    statusText: "Client Closed Request",
    type: "error",
    url: ""
};
/**
 * A raw response indicating an unknown error.
 */ exports.unknownRawResponse = {
    headers: new Headers_1.Headers(),
    redirected: false,
    status: 0,
    statusText: "Unknown Error",
    type: "error",
    url: ""
};
/**
 * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
 * excluding the `body` and `bodyUsed` fields.
 *
 * @param response - The `RawResponse` object to convert.
 * @returns A `RawResponse` object containing the extracted properties of the input response.
 */ function toRawResponse(response) {
    return {
        headers: response.headers,
        redirected: response.redirected,
        status: response.status,
        statusText: response.statusText,
        type: response.type,
        url: response.url
    };
}
}}),
"[project]/node_modules/hume/core/fetcher/Supplier.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Supplier = void 0;
exports.Supplier = {
    get: (supplier)=>{
        if (typeof supplier === "function") {
            return supplier();
        } else {
            return supplier;
        }
    }
};
}}),
"[project]/node_modules/hume/core/fetcher/createRequestUrl.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createRequestUrl = createRequestUrl;
const qs_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/qs/lib/index.js [app-rsc] (ecmascript)"));
function createRequestUrl(baseUrl, queryParameters) {
    return Object.keys(queryParameters !== null && queryParameters !== void 0 ? queryParameters : {}).length > 0 ? `${baseUrl}?${qs_1.default.stringify(queryParameters, {
        arrayFormat: "repeat"
    })}` : baseUrl;
}
}}),
"[project]/node_modules/hume/core/runtime/runtime.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RUNTIME = void 0;
/**
 * A constant that indicates which environment and version the SDK is running in.
 */ exports.RUNTIME = evaluateRuntime();
function evaluateRuntime() {
    var _a, _b, _c, _d, _e;
    /**
     * A constant that indicates whether the environment the code is running is a Web Browser.
     */ const isBrowser = "undefined" !== "undefined" && typeof window.document !== "undefined";
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    /**
     * A constant that indicates whether the environment the code is running is Cloudflare.
     * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
     */ const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
    if (isCloudflare) {
        return {
            type: "workerd"
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Edge Runtime.
     * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
     */ const isEdgeRuntime = typeof EdgeRuntime === "string";
    if (isEdgeRuntime) {
        return {
            type: "edge-runtime"
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */ const isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" || ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
    if (isWebWorker) {
        return {
            type: "web-worker"
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Deno.
     * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
     */ const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    if (isDeno) {
        return {
            type: "deno",
            version: Deno.version.deno
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */ const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    if (isBun) {
        return {
            type: "bun",
            version: Bun.version
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Node.JS.
     */ const isNode = typeof process !== "undefined" && "version" in process && !!process.version && "versions" in process && !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
    if (isNode) {
        return {
            type: "node",
            version: process.versions.node,
            parsedVersion: Number(process.versions.node.split(".")[0])
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is in React-Native.
     * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
     */ const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
    if (isReactNative) {
        return {
            type: "react-native"
        };
    }
    return {
        type: "unknown"
    };
}
}}),
"[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RUNTIME = void 0;
var runtime_1 = __turbopack_context__.r("[project]/node_modules/hume/core/runtime/runtime.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "RUNTIME", {
    enumerable: true,
    get: function() {
        return runtime_1.RUNTIME;
    }
});
}}),
"[project]/node_modules/hume/core/fetcher/getFetchFn.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getFetchFn = getFetchFn;
const index_1 = __turbopack_context__.r("[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)");
/**
 * Returns a fetch function based on the runtime
 */ function getFetchFn() {
    return __awaiter(this, void 0, void 0, function*() {
        // In Node.js 18+ environments, use native fetch
        if (index_1.RUNTIME.type === "node" && index_1.RUNTIME.parsedVersion != null && index_1.RUNTIME.parsedVersion >= 18) {
            return fetch;
        }
        // In Node.js 18 or lower environments, the SDK always uses`node-fetch`.
        if (index_1.RUNTIME.type === "node") {
            return (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/node-fetch/lib/index.mjs [app-rsc] (ecmascript)")))).default;
        }
        // Otherwise the SDK uses global fetch if available,
        // and falls back to node-fetch.
        if (typeof fetch == "function") {
            return fetch;
        }
        // Defaults to node `node-fetch` if global fetch isn't available
        return (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/node-fetch/lib/index.mjs [app-rsc] (ecmascript)")))).default;
    });
}
}}),
"[project]/node_modules/hume/core/fetcher/getRequestBody.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRequestBody = getRequestBody;
const json_1 = __turbopack_context__.r("[project]/node_modules/hume/core/json.js [app-rsc] (ecmascript)");
function getRequestBody(_a) {
    return __awaiter(this, arguments, void 0, function*({ body, type }) {
        if (type.includes("json")) {
            return (0, json_1.toJson)(body);
        } else {
            return body;
        }
    });
}
}}),
"[project]/node_modules/hume/core/fetcher/BinaryResponse.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBinaryResponse = getBinaryResponse;
function getBinaryResponse(response) {
    return {
        get bodyUsed () {
            return response.bodyUsed;
        },
        stream: ()=>response.body,
        arrayBuffer: response.arrayBuffer.bind(response),
        blob: response.blob.bind(response),
        bytes: response.bytes.bind(response)
    };
}
}}),
"[project]/node_modules/hume/core/fetcher/ResponseWithBody.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isResponseWithBody = isResponseWithBody;
function isResponseWithBody(response) {
    return response.body != null;
}
}}),
"[project]/node_modules/hume/core/fetcher/stream-wrappers/NodePre18StreamWrapper.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NodePre18StreamWrapper = void 0;
class NodePre18StreamWrapper {
    constructor(readableStream){
        this.readableStream = readableStream;
    }
    on(event, callback) {
        this.readableStream.on(event, callback);
    }
    off(event, callback) {
        this.readableStream.off(event, callback);
    }
    pipe(dest) {
        this.readableStream.pipe(dest);
        return dest;
    }
    pipeTo(dest) {
        return this.pipe(dest);
    }
    unpipe(dest) {
        if (dest) {
            this.readableStream.unpipe(dest);
        } else {
            this.readableStream.unpipe();
        }
    }
    destroy(error) {
        this.readableStream.destroy(error);
    }
    pause() {
        this.readableStream.pause();
    }
    resume() {
        this.readableStream.resume();
    }
    get isPaused() {
        return this.readableStream.isPaused();
    }
    read() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>{
                const chunk = this.readableStream.read();
                if (chunk) {
                    resolve(chunk);
                } else {
                    this.readableStream.once("readable", ()=>{
                        const chunk = this.readableStream.read();
                        resolve(chunk);
                    });
                    this.readableStream.once("error", reject);
                }
            });
        });
    }
    setEncoding(encoding) {
        this.readableStream.setEncoding(encoding);
        this.encoding = encoding;
    }
    text() {
        return __awaiter(this, void 0, void 0, function*() {
            var _a, e_1, _b, _c;
            const chunks = [];
            const encoder = new TextEncoder();
            this.readableStream.setEncoding(this.encoding || "utf-8");
            try {
                for(var _d = true, _e = __asyncValues(this.readableStream), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){
                    _c = _f.value;
                    _d = false;
                    const chunk = _c;
                    chunks.push(encoder.encode(chunk));
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            const decoder = new TextDecoder(this.encoding || "utf-8");
            return decoder.decode(Buffer.concat(chunks));
        });
    }
    json() {
        return __awaiter(this, void 0, void 0, function*() {
            const text = yield this.text();
            return JSON.parse(text);
        });
    }
    [Symbol.asyncIterator]() {
        const readableStream = this.readableStream;
        const iterator = readableStream[Symbol.asyncIterator]();
        // Create and return an async iterator that yields buffers
        return {
            next () {
                return __awaiter(this, void 0, void 0, function*() {
                    const { value, done } = yield iterator.next();
                    return {
                        value: value,
                        done
                    };
                });
            },
            [Symbol.asyncIterator] () {
                return this;
            }
        };
    }
}
exports.NodePre18StreamWrapper = NodePre18StreamWrapper;
}}),
"[project]/node_modules/hume/core/fetcher/stream-wrappers/UndiciStreamWrapper.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UndiciStreamWrapper = void 0;
class UndiciStreamWrapper {
    constructor(readableStream){
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: []
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }
    on(event, callback) {
        var _a;
        (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(callback);
    }
    off(event, callback) {
        var _a;
        this.events[event] = (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.filter((cb)=>cb !== callback);
    }
    pipe(dest) {
        this.on("data", (chunk)=>{
            if (dest instanceof UndiciStreamWrapper) {
                dest._write(chunk);
            } else {
                const writer = dest.getWriter();
                writer.write(chunk).then(()=>writer.releaseLock());
            }
        });
        this.on("end", ()=>{
            if (dest instanceof UndiciStreamWrapper) {
                dest._end();
            } else {
                const writer = dest.getWriter();
                writer.close();
            }
        });
        this.on("error", (error)=>{
            if (dest instanceof UndiciStreamWrapper) {
                dest._error(error);
            } else {
                const writer = dest.getWriter();
                writer.abort(error);
            }
        });
        this._startReading();
        return dest;
    }
    pipeTo(dest) {
        return this.pipe(dest);
    }
    unpipe(dest) {
        this.off("data", (chunk)=>{
            if (dest instanceof UndiciStreamWrapper) {
                dest._write(chunk);
            } else {
                const writer = dest.getWriter();
                writer.write(chunk).then(()=>writer.releaseLock());
            }
        });
        this.off("end", ()=>{
            if (dest instanceof UndiciStreamWrapper) {
                dest._end();
            } else {
                const writer = dest.getWriter();
                writer.close();
            }
        });
        this.off("error", (error)=>{
            if (dest instanceof UndiciStreamWrapper) {
                dest._error(error);
            } else {
                const writer = dest.getWriter();
                writer.abort(error);
            }
        });
    }
    destroy(error) {
        this.reader.cancel(error).then(()=>{
            this._emit("close");
        }).catch((err)=>{
            this._emit("error", err);
        });
    }
    pause() {
        this.paused = true;
        this._emit("pause");
    }
    resume() {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }
    get isPaused() {
        return this.paused;
    }
    read() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.paused) {
                yield new Promise((resolve)=>{
                    this.resumeCallback = resolve;
                });
            }
            const { done, value } = yield this.reader.read();
            if (done) {
                return undefined;
            }
            return value;
        });
    }
    setEncoding(encoding) {
        this.encoding = encoding;
    }
    text() {
        return __awaiter(this, void 0, void 0, function*() {
            const chunks = [];
            while(true){
                const { done, value } = yield this.reader.read();
                if (done) {
                    break;
                }
                if (value) {
                    chunks.push(value);
                }
            }
            const decoder = new TextDecoder(this.encoding || "utf-8");
            return decoder.decode((yield new Blob(chunks).arrayBuffer()));
        });
    }
    json() {
        return __awaiter(this, void 0, void 0, function*() {
            const text = yield this.text();
            return JSON.parse(text);
        });
    }
    _write(chunk) {
        this._emit("data", chunk);
    }
    _end() {
        this._emit("end");
    }
    _error(error) {
        this._emit("error", error);
    }
    _emit(event, data) {
        if (this.events[event]) {
            for (const callback of this.events[event] || []){
                callback(data);
            }
        }
    }
    _startReading() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                this._emit("readable");
                while(true){
                    if (this.paused) {
                        yield new Promise((resolve)=>{
                            this.resumeCallback = resolve;
                        });
                    }
                    const { done, value } = yield this.reader.read();
                    if (done) {
                        this._emit("end");
                        this._emit("close");
                        break;
                    }
                    if (value) {
                        this._emit("data", value);
                    }
                }
            } catch (error) {
                this._emit("error", error);
            }
        });
    }
    [Symbol.asyncIterator]() {
        return {
            next: ()=>__awaiter(this, void 0, void 0, function*() {
                    if (this.paused) {
                        yield new Promise((resolve)=>{
                            this.resumeCallback = resolve;
                        });
                    }
                    const { done, value } = yield this.reader.read();
                    if (done) {
                        return {
                            done: true,
                            value: undefined
                        };
                    }
                    return {
                        done: false,
                        value
                    };
                }),
            [Symbol.asyncIterator] () {
                return this;
            }
        };
    }
}
exports.UndiciStreamWrapper = UndiciStreamWrapper;
}}),
"[project]/node_modules/hume/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Node18UniversalStreamWrapper = void 0;
class Node18UniversalStreamWrapper {
    constructor(readableStream){
        this.readableStream = readableStream;
        this.reader = this.readableStream.getReader();
        this.events = {
            data: [],
            end: [],
            error: [],
            readable: [],
            close: [],
            pause: [],
            resume: []
        };
        this.paused = false;
        this.resumeCallback = null;
        this.encoding = null;
    }
    on(event, callback) {
        var _a;
        (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.push(callback);
    }
    off(event, callback) {
        var _a;
        this.events[event] = (_a = this.events[event]) === null || _a === void 0 ? void 0 : _a.filter((cb)=>cb !== callback);
    }
    pipe(dest) {
        this.on("data", (chunk)=>__awaiter(this, void 0, void 0, function*() {
                if (dest instanceof Node18UniversalStreamWrapper) {
                    dest._write(chunk);
                } else if (dest instanceof WritableStream) {
                    const writer = dest.getWriter();
                    writer.write(chunk).then(()=>writer.releaseLock());
                } else {
                    dest.write(chunk);
                }
            }));
        this.on("end", ()=>__awaiter(this, void 0, void 0, function*() {
                if (dest instanceof Node18UniversalStreamWrapper) {
                    dest._end();
                } else if (dest instanceof WritableStream) {
                    const writer = dest.getWriter();
                    writer.close();
                } else {
                    dest.end();
                }
            }));
        this.on("error", (error)=>__awaiter(this, void 0, void 0, function*() {
                if (dest instanceof Node18UniversalStreamWrapper) {
                    dest._error(error);
                } else if (dest instanceof WritableStream) {
                    const writer = dest.getWriter();
                    writer.abort(error);
                } else {
                    dest.destroy(error);
                }
            }));
        this._startReading();
        return dest;
    }
    pipeTo(dest) {
        return this.pipe(dest);
    }
    unpipe(dest) {
        this.off("data", (chunk)=>__awaiter(this, void 0, void 0, function*() {
                if (dest instanceof Node18UniversalStreamWrapper) {
                    dest._write(chunk);
                } else if (dest instanceof WritableStream) {
                    const writer = dest.getWriter();
                    writer.write(chunk).then(()=>writer.releaseLock());
                } else {
                    dest.write(chunk);
                }
            }));
        this.off("end", ()=>__awaiter(this, void 0, void 0, function*() {
                if (dest instanceof Node18UniversalStreamWrapper) {
                    dest._end();
                } else if (dest instanceof WritableStream) {
                    const writer = dest.getWriter();
                    writer.close();
                } else {
                    dest.end();
                }
            }));
        this.off("error", (error)=>__awaiter(this, void 0, void 0, function*() {
                if (dest instanceof Node18UniversalStreamWrapper) {
                    dest._error(error);
                } else if (dest instanceof WritableStream) {
                    const writer = dest.getWriter();
                    writer.abort(error);
                } else {
                    dest.destroy(error);
                }
            }));
    }
    destroy(error) {
        this.reader.cancel(error).then(()=>{
            this._emit("close");
        }).catch((err)=>{
            this._emit("error", err);
        });
    }
    pause() {
        this.paused = true;
        this._emit("pause");
    }
    resume() {
        if (this.paused) {
            this.paused = false;
            this._emit("resume");
            if (this.resumeCallback) {
                this.resumeCallback();
                this.resumeCallback = null;
            }
        }
    }
    get isPaused() {
        return this.paused;
    }
    read() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.paused) {
                yield new Promise((resolve)=>{
                    this.resumeCallback = resolve;
                });
            }
            const { done, value } = yield this.reader.read();
            if (done) {
                return undefined;
            }
            return value;
        });
    }
    setEncoding(encoding) {
        this.encoding = encoding;
    }
    text() {
        return __awaiter(this, void 0, void 0, function*() {
            const chunks = [];
            while(true){
                const { done, value } = yield this.reader.read();
                if (done) {
                    break;
                }
                if (value) {
                    chunks.push(value);
                }
            }
            const decoder = new TextDecoder(this.encoding || "utf-8");
            return decoder.decode((yield new Blob(chunks).arrayBuffer()));
        });
    }
    json() {
        return __awaiter(this, void 0, void 0, function*() {
            const text = yield this.text();
            return JSON.parse(text);
        });
    }
    _write(chunk) {
        this._emit("data", chunk);
    }
    _end() {
        this._emit("end");
    }
    _error(error) {
        this._emit("error", error);
    }
    _emit(event, data) {
        if (this.events[event]) {
            for (const callback of this.events[event] || []){
                callback(data);
            }
        }
    }
    _startReading() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                this._emit("readable");
                while(true){
                    if (this.paused) {
                        yield new Promise((resolve)=>{
                            this.resumeCallback = resolve;
                        });
                    }
                    const { done, value } = yield this.reader.read();
                    if (done) {
                        this._emit("end");
                        this._emit("close");
                        break;
                    }
                    if (value) {
                        this._emit("data", value);
                    }
                }
            } catch (error) {
                this._emit("error", error);
            }
        });
    }
    [Symbol.asyncIterator]() {
        return {
            next: ()=>__awaiter(this, void 0, void 0, function*() {
                    if (this.paused) {
                        yield new Promise((resolve)=>{
                            this.resumeCallback = resolve;
                        });
                    }
                    const { done, value } = yield this.reader.read();
                    if (done) {
                        return {
                            done: true,
                            value: undefined
                        };
                    }
                    return {
                        done: false,
                        value
                    };
                }),
            [Symbol.asyncIterator] () {
                return this;
            }
        };
    }
}
exports.Node18UniversalStreamWrapper = Node18UniversalStreamWrapper;
}}),
"[project]/node_modules/hume/core/fetcher/stream-wrappers/chooseStreamWrapper.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chooseStreamWrapper = chooseStreamWrapper;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)");
function chooseStreamWrapper(responseBody) {
    return __awaiter(this, void 0, void 0, function*() {
        if (runtime_1.RUNTIME.type === "node" && runtime_1.RUNTIME.parsedVersion != null && runtime_1.RUNTIME.parsedVersion >= 18) {
            return new (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/hume/core/fetcher/stream-wrappers/Node18UniversalStreamWrapper.js [app-rsc] (ecmascript)")))).Node18UniversalStreamWrapper(responseBody);
        } else if (runtime_1.RUNTIME.type !== "node" && typeof fetch === "function") {
            return new (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/hume/core/fetcher/stream-wrappers/UndiciStreamWrapper.js [app-rsc] (ecmascript)")))).UndiciStreamWrapper(responseBody);
        } else {
            return new (yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/hume/core/fetcher/stream-wrappers/NodePre18StreamWrapper.js [app-rsc] (ecmascript)")))).NodePre18StreamWrapper(responseBody);
        }
    });
}
}}),
"[project]/node_modules/hume/core/fetcher/getResponseBody.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getResponseBody = getResponseBody;
const BinaryResponse_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/BinaryResponse.js [app-rsc] (ecmascript)");
const ResponseWithBody_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/ResponseWithBody.js [app-rsc] (ecmascript)");
const chooseStreamWrapper_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/stream-wrappers/chooseStreamWrapper.js [app-rsc] (ecmascript)");
function getResponseBody(response, responseType) {
    return __awaiter(this, void 0, void 0, function*() {
        if (!(0, ResponseWithBody_1.isResponseWithBody)(response)) {
            return undefined;
        }
        switch(responseType){
            case "binary-response":
                return (0, BinaryResponse_1.getBinaryResponse)(response);
            case "blob":
                return yield response.blob();
            case "arrayBuffer":
                return yield response.arrayBuffer();
            case "sse":
                return response.body;
            case "streaming":
                return (0, chooseStreamWrapper_1.chooseStreamWrapper)(response.body);
            case "text":
                return yield response.text();
        }
        // if responseType is "json" or not specified, try to parse as JSON
        const text = yield response.text();
        if (text.length > 0) {
            try {
                let responseBody = JSON.parse(text);
                return responseBody;
            } catch (err) {
                return {
                    ok: false,
                    error: {
                        reason: "non-json",
                        statusCode: response.status,
                        rawBody: text
                    }
                };
            }
        }
        return undefined;
    });
}
}}),
"[project]/node_modules/hume/core/fetcher/signals.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getTimeoutSignal = getTimeoutSignal;
exports.anySignal = anySignal;
const TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
    const controller = new AbortController();
    const abortId = setTimeout(()=>controller.abort(TIMEOUT), timeoutMs);
    return {
        signal: controller.signal,
        abortId
    };
}
/**
 * Returns an abort signal that is getting aborted when
 * at least one of the specified abort signals is aborted.
 *
 * Requires at least node.js 18.
 */ function anySignal(...args) {
    // Allowing signals to be passed either as array
    // of signals or as multiple arguments.
    const signals = args.length === 1 && Array.isArray(args[0]) ? args[0] : args;
    const controller = new AbortController();
    for (const signal of signals){
        if (signal.aborted) {
            // Exiting early if one of the signals
            // is already aborted.
            controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
            break;
        }
        // Listening for signals and removing the listeners
        // when at least one symbol is aborted.
        signal.addEventListener("abort", ()=>controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
            signal: controller.signal
        });
    }
    return controller.signal;
}
}}),
"[project]/node_modules/hume/core/fetcher/makeRequest.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeRequest = void 0;
const signals_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/signals.js [app-rsc] (ecmascript)");
const makeRequest = (fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex)=>__awaiter(void 0, void 0, void 0, function*() {
        const signals = [];
        // Add timeout signal
        let timeoutAbortId = undefined;
        if (timeoutMs != null) {
            const { signal, abortId } = (0, signals_1.getTimeoutSignal)(timeoutMs);
            timeoutAbortId = abortId;
            signals.push(signal);
        }
        // Add arbitrary signal
        if (abortSignal != null) {
            signals.push(abortSignal);
        }
        let newSignals = (0, signals_1.anySignal)(signals);
        const response = yield fetchFn(url, {
            method: method,
            headers,
            body: requestBody,
            signal: newSignals,
            credentials: withCredentials ? "include" : undefined,
            // @ts-ignore
            duplex
        });
        if (timeoutAbortId != null) {
            clearTimeout(timeoutAbortId);
        }
        return response;
    });
exports.makeRequest = makeRequest;
}}),
"[project]/node_modules/hume/core/fetcher/requestWithRetries.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.requestWithRetries = requestWithRetries;
const INITIAL_RETRY_DELAY = 1000; // in milliseconds
const MAX_RETRY_DELAY = 60000; // in milliseconds
const DEFAULT_MAX_RETRIES = 2;
const JITTER_FACTOR = 0.2; // 20% random jitter
function addJitter(delay) {
    // Generate a random value between -JITTER_FACTOR and +JITTER_FACTOR
    const jitterMultiplier = 1 + (Math.random() * 2 - 1) * JITTER_FACTOR;
    return delay * jitterMultiplier;
}
function requestWithRetries(requestFn_1) {
    return __awaiter(this, arguments, void 0, function*(requestFn, maxRetries = DEFAULT_MAX_RETRIES) {
        let response = yield requestFn();
        for(let i = 0; i < maxRetries; ++i){
            if ([
                408,
                429
            ].includes(response.status) || response.status >= 500) {
                // Calculate base delay using exponential backoff (in milliseconds)
                const baseDelay = Math.min(INITIAL_RETRY_DELAY * Math.pow(2, i), MAX_RETRY_DELAY);
                // Add jitter to the delay
                const delayWithJitter = addJitter(baseDelay);
                yield new Promise((resolve)=>setTimeout(resolve, delayWithJitter));
                response = yield requestFn();
            } else {
                break;
            }
        }
        return response;
    });
}
}}),
"[project]/node_modules/hume/core/fetcher/Fetcher.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetcher = void 0;
exports.fetcherImpl = fetcherImpl;
const json_1 = __turbopack_context__.r("[project]/node_modules/hume/core/json.js [app-rsc] (ecmascript)");
const RawResponse_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/RawResponse.js [app-rsc] (ecmascript)");
const Supplier_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/Supplier.js [app-rsc] (ecmascript)");
const createRequestUrl_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/createRequestUrl.js [app-rsc] (ecmascript)");
const getFetchFn_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/getFetchFn.js [app-rsc] (ecmascript)");
const getRequestBody_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/getRequestBody.js [app-rsc] (ecmascript)");
const getResponseBody_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/getResponseBody.js [app-rsc] (ecmascript)");
const makeRequest_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/makeRequest.js [app-rsc] (ecmascript)");
const requestWithRetries_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/requestWithRetries.js [app-rsc] (ecmascript)");
function getHeaders(args) {
    return __awaiter(this, void 0, void 0, function*() {
        const newHeaders = {};
        if (args.body !== undefined && args.contentType != null) {
            newHeaders["Content-Type"] = args.contentType;
        }
        if (args.headers == null) {
            return newHeaders;
        }
        for (const [key, value] of Object.entries(args.headers)){
            const result = yield Supplier_1.Supplier.get(value);
            if (typeof result === "string") {
                newHeaders[key] = result;
                continue;
            }
            if (result == null) {
                continue;
            }
            newHeaders[key] = `${result}`;
        }
        return newHeaders;
    });
}
function fetcherImpl(args) {
    return __awaiter(this, void 0, void 0, function*() {
        const url = (0, createRequestUrl_1.createRequestUrl)(args.url, args.queryParameters);
        const requestBody = yield (0, getRequestBody_1.getRequestBody)({
            body: args.body,
            type: args.requestType === "json" ? "json" : "other"
        });
        const fetchFn = yield (0, getFetchFn_1.getFetchFn)();
        try {
            const response = yield (0, requestWithRetries_1.requestWithRetries)(()=>__awaiter(this, void 0, void 0, function*() {
                    return (0, makeRequest_1.makeRequest)(fetchFn, url, args.method, (yield getHeaders(args)), requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
                }), args.maxRetries);
            const responseBody = yield (0, getResponseBody_1.getResponseBody)(response, args.responseType);
            if (response.status >= 200 && response.status < 400) {
                return {
                    ok: true,
                    body: responseBody,
                    headers: response.headers,
                    rawResponse: (0, RawResponse_1.toRawResponse)(response)
                };
            } else {
                return {
                    ok: false,
                    error: {
                        reason: "status-code",
                        statusCode: response.status,
                        body: responseBody
                    },
                    rawResponse: (0, RawResponse_1.toRawResponse)(response)
                };
            }
        } catch (error) {
            if (args.abortSignal != null && args.abortSignal.aborted) {
                return {
                    ok: false,
                    error: {
                        reason: "unknown",
                        errorMessage: "The user aborted a request"
                    },
                    rawResponse: RawResponse_1.abortRawResponse
                };
            } else if (error instanceof Error && error.name === "AbortError") {
                return {
                    ok: false,
                    error: {
                        reason: "timeout"
                    },
                    rawResponse: RawResponse_1.abortRawResponse
                };
            } else if (error instanceof Error) {
                return {
                    ok: false,
                    error: {
                        reason: "unknown",
                        errorMessage: error.message
                    },
                    rawResponse: RawResponse_1.unknownRawResponse
                };
            }
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: (0, json_1.toJson)(error)
                },
                rawResponse: RawResponse_1.unknownRawResponse
            };
        }
    });
}
exports.fetcher = fetcherImpl;
}}),
"[project]/node_modules/hume/core/fetcher/getHeader.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHeader = getHeader;
function getHeader(headers, header) {
    for (const [headerKey, headerValue] of Object.entries(headers)){
        if (headerKey.toLowerCase() === header.toLowerCase()) {
            return headerValue;
        }
    }
    return undefined;
}
}}),
"[project]/node_modules/hume/core/fetcher/HttpResponsePromise.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpResponsePromise = void 0;
/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */ class HttpResponsePromise extends Promise {
    constructor(promise){
        // Initialize with a no-op to avoid premature parsing
        super((resolve)=>{
            resolve(undefined);
        });
        this.innerPromise = promise;
    }
    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */ static fromFunction(fn, ...args) {
        return new HttpResponsePromise(fn(...args));
    }
    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */ static interceptFunction(fn) {
        return (...args)=>{
            return HttpResponsePromise.fromPromise(fn(...args));
        };
    }
    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */ static fromPromise(promise) {
        return new HttpResponsePromise(promise);
    }
    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */ static fromExecutor(executor) {
        const promise = new Promise(executor);
        return new HttpResponsePromise(promise);
    }
    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */ static fromResult(result) {
        const promise = Promise.resolve(result);
        return new HttpResponsePromise(promise);
    }
    unwrap() {
        if (!this.unwrappedPromise) {
            this.unwrappedPromise = this.innerPromise.then(({ data })=>data);
        }
        return this.unwrappedPromise;
    }
    /** @inheritdoc */ then(onfulfilled, onrejected) {
        return this.unwrap().then(onfulfilled, onrejected);
    }
    /** @inheritdoc */ catch(onrejected) {
        return this.unwrap().catch(onrejected);
    }
    /** @inheritdoc */ finally(onfinally) {
        return this.unwrap().finally(onfinally);
    }
    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */ withRawResponse() {
        return __awaiter(this, void 0, void 0, function*() {
            return yield this.innerPromise;
        });
    }
}
exports.HttpResponsePromise = HttpResponsePromise;
}}),
"[project]/node_modules/hume/core/fetcher/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpResponsePromise = exports.unknownRawResponse = exports.toRawResponse = exports.abortRawResponse = exports.Supplier = exports.getHeader = exports.fetcher = void 0;
var Fetcher_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/Fetcher.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "fetcher", {
    enumerable: true,
    get: function() {
        return Fetcher_1.fetcher;
    }
});
var getHeader_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/getHeader.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getHeader", {
    enumerable: true,
    get: function() {
        return getHeader_1.getHeader;
    }
});
var Supplier_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/Supplier.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Supplier", {
    enumerable: true,
    get: function() {
        return Supplier_1.Supplier;
    }
});
var RawResponse_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/RawResponse.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "abortRawResponse", {
    enumerable: true,
    get: function() {
        return RawResponse_1.abortRawResponse;
    }
});
Object.defineProperty(exports, "toRawResponse", {
    enumerable: true,
    get: function() {
        return RawResponse_1.toRawResponse;
    }
});
Object.defineProperty(exports, "unknownRawResponse", {
    enumerable: true,
    get: function() {
        return RawResponse_1.unknownRawResponse;
    }
});
var HttpResponsePromise_1 = __turbopack_context__.r("[project]/node_modules/hume/core/fetcher/HttpResponsePromise.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HttpResponsePromise", {
    enumerable: true,
    get: function() {
        return HttpResponsePromise_1.HttpResponsePromise;
    }
});
}}),
"[project]/node_modules/hume/core/stream/Stream.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stream = void 0;
exports.readableStreamAsyncIterable = readableStreamAsyncIterable;
const runtime_1 = __turbopack_context__.r("[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)");
const DATA_PREFIX = "data:";
class Stream {
    constructor({ stream, parse, eventShape, signal }){
        this.controller = new AbortController();
        this.stream = stream;
        this.parse = parse;
        if (eventShape.type === "sse") {
            this.prefix = DATA_PREFIX;
            this.messageTerminator = "\n";
            this.streamTerminator = eventShape.streamTerminator;
        } else {
            this.messageTerminator = eventShape.messageTerminator;
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", ()=>this.controller.abort());
    }
    iterMessages() {
        return __asyncGenerator(this, arguments, function* iterMessages_1() {
            var _a, e_1, _b, _c;
            this.controller.signal;
            const stream = readableStreamAsyncIterable(this.stream);
            let buf = "";
            let prefixSeen = false;
            try {
                for(var _d = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true){
                    _c = stream_1_1.value;
                    _d = false;
                    const chunk = _c;
                    buf += this.decodeChunk(chunk);
                    let terminatorIndex;
                    while((terminatorIndex = buf.indexOf(this.messageTerminator)) >= 0){
                        let line = buf.slice(0, terminatorIndex + 1);
                        buf = buf.slice(terminatorIndex + this.messageTerminator.length);
                        if (!line.trim()) {
                            continue;
                        }
                        if (!prefixSeen && this.prefix != null) {
                            const prefixIndex = line.indexOf(this.prefix);
                            if (prefixIndex === -1) {
                                continue;
                            }
                            prefixSeen = true;
                            line = line.slice(prefixIndex + this.prefix.length);
                        }
                        if (this.streamTerminator != null && line.includes(this.streamTerminator)) {
                            return yield __await(void 0);
                        }
                        const message = yield __await(this.parse(JSON.parse(line)));
                        yield yield __await(message);
                        prefixSeen = false;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_d && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            var _b, e_2, _c, _d;
            try {
                for(var _e = true, _f = __asyncValues(this.iterMessages()), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true){
                    _d = _g.value;
                    _e = false;
                    const message = _d;
                    yield yield __await(message);
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        });
    }
    decodeChunk(chunk) {
        let decoded = "";
        // If TextDecoder is present, use it
        if (typeof TextDecoder !== "undefined") {
            const decoder = new TextDecoder("utf8");
            decoded += decoder.decode(chunk);
        } else if (runtime_1.RUNTIME.type === "node" && typeof chunk !== "undefined") {
            decoded += Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        return decoded;
    }
}
exports.Stream = Stream;
/**
 * Browser polyfill for ReadableStream
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any
function readableStreamAsyncIterable(stream) {
    if (stream[Symbol.asyncIterator]) {
        return stream;
    }
    const reader = stream.getReader();
    return {
        next () {
            return __awaiter(this, void 0, void 0, function*() {
                try {
                    const result = yield reader.read();
                    if (result === null || result === void 0 ? void 0 : result.done) {
                        reader.releaseLock();
                    } // release lock when stream becomes closed
                    return result;
                } catch (e) {
                    reader.releaseLock(); // release lock when stream becomes errored
                    throw e;
                }
            });
        },
        return () {
            return __awaiter(this, void 0, void 0, function*() {
                const cancelPromise = reader.cancel();
                reader.releaseLock();
                yield cancelPromise;
                return {
                    done: true,
                    value: undefined
                };
            });
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    };
}
}}),
"[project]/node_modules/hume/core/stream/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Stream = void 0;
var Stream_1 = __turbopack_context__.r("[project]/node_modules/hume/core/stream/Stream.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Stream", {
    enumerable: true,
    get: function() {
        return Stream_1.Stream;
    }
});
}}),
"[project]/node_modules/hume/core/utils/setObjectProperty.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setObjectProperty = setObjectProperty;
/**
 * Sets the value at path of object. If a portion of path doesnt exist its created. This is
 * inspired by Lodash's set function, but is simplified to accommodate our use case.
 * For more details, see https://lodash.com/docs/4.17.15#set.
 *
 * @param object The object to modify.
 * @param path The path of the property to set.
 * @param value The value to set.
 * @return Returns object.
 */ function setObjectProperty(object, path, value) {
    if (object == null) {
        return object;
    }
    const keys = path.split(".");
    if (keys.length === 0) {
        // Invalid path; do nothing.
        return object;
    }
    let current = object;
    for(let i = 0; i < keys.length - 1; i++){
        const key = keys[i];
        if (key == null) {
            continue;
        }
        if (!current[key] || typeof current[key] !== "object") {
            current[key] = {};
        }
        current = current[key];
    }
    const lastKey = keys[keys.length - 1];
    if (lastKey == null) {
        // Unreachable.
        return object;
    }
    current[lastKey] = value;
    return object;
}
}}),
"[project]/node_modules/hume/core/utils/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setObjectProperty = void 0;
var setObjectProperty_1 = __turbopack_context__.r("[project]/node_modules/hume/core/utils/setObjectProperty.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "setObjectProperty", {
    enumerable: true,
    get: function() {
        return setObjectProperty_1.setObjectProperty;
    }
});
}}),
"[project]/node_modules/hume/core/pagination/Page.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    //TURBOPACK unreachable
    ;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
var __asyncValues = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Page = void 0;
/**
 * A page of results from a paginated API.
 *
 * @template T The type of the items in the page.
 */ class Page {
    constructor({ response, rawResponse, hasNextPage, getItems, loadPage }){
        this.response = response;
        this.rawResponse = rawResponse;
        this.data = getItems(response);
        this._hasNextPage = hasNextPage;
        this.getItems = getItems;
        this.loadNextPage = loadPage;
    }
    /**
     * Retrieves the next page
     * @returns this
     */ getNextPage() {
        return __awaiter(this, void 0, void 0, function*() {
            const { data, rawResponse } = yield this.loadNextPage(this.response).withRawResponse();
            this.response = data;
            this.rawResponse = rawResponse;
            this.data = this.getItems(this.response);
            return this;
        });
    }
    /**
     * @returns whether there is a next page to load
     */ hasNextPage() {
        return this._hasNextPage(this.response);
    }
    iterMessages() {
        return __asyncGenerator(this, arguments, function* iterMessages_1() {
            for (const item of this.data){
                yield yield __await(item);
            }
            while(this.hasNextPage()){
                yield __await(this.getNextPage());
                for (const item of this.data){
                    yield yield __await(item);
                }
            }
        });
    }
    [Symbol.asyncIterator]() {
        return __asyncGenerator(this, arguments, function* _a() {
            var _b, e_1, _c, _d;
            try {
                for(var _e = true, _f = __asyncValues(this.iterMessages()), _g; _g = yield __await(_f.next()), _b = _g.done, !_b; _e = true){
                    _d = _g.value;
                    _e = false;
                    const message = _d;
                    yield yield __await(message);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (!_e && !_b && (_c = _f.return)) yield __await(_c.call(_f));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        });
    }
}
exports.Page = Page;
}}),
"[project]/node_modules/hume/core/pagination/Pageable.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pageable = void 0;
const Page_1 = __turbopack_context__.r("[project]/node_modules/hume/core/pagination/Page.js [app-rsc] (ecmascript)");
class Pageable extends Page_1.Page {
    constructor(args){
        super(args);
    }
}
exports.Pageable = Pageable;
}}),
"[project]/node_modules/hume/core/pagination/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pageable = exports.Page = void 0;
var Page_1 = __turbopack_context__.r("[project]/node_modules/hume/core/pagination/Page.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Page", {
    enumerable: true,
    get: function() {
        return Page_1.Page;
    }
});
var Pageable_1 = __turbopack_context__.r("[project]/node_modules/hume/core/pagination/Pageable.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Pageable", {
    enumerable: true,
    get: function() {
        return Pageable_1.Pageable;
    }
});
}}),
"[project]/node_modules/hume/core/form-data-utils/encodeAsFormParameter.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeAsFormParameter = encodeAsFormParameter;
const qs_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/qs/lib/index.js [app-rsc] (ecmascript)"));
/**
 * Takes an unknown value, stringifies it using qs, and parses it into a key-value record
 */ function encodeAsFormParameter(value) {
    const stringified = qs_1.default.stringify(value, {
        encode: false
    });
    const keyValuePairs = stringified.split("&").map((pair)=>{
        const [key, value] = pair.split("=");
        return [
            key,
            value
        ];
    });
    return Object.fromEntries(keyValuePairs);
}
}}),
"[project]/node_modules/hume/core/form-data-utils/FormDataWrapper.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FormDataWrapper = void 0;
exports.newFormData = newFormData;
const json_js_1 = __turbopack_context__.r("[project]/node_modules/hume/core/json.js [app-rsc] (ecmascript)");
const index_js_1 = __turbopack_context__.r("[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)");
function isNamedValue(value) {
    return typeof value === "object" && value != null && "name" in value;
}
function isPathedValue(value) {
    return typeof value === "object" && value != null && "path" in value;
}
function isStreamLike(value) {
    return typeof value === "object" && value != null && ("read" in value || "pipe" in value);
}
function isReadableStream(value) {
    return typeof value === "object" && value != null && "getReader" in value;
}
function isBuffer(value) {
    return typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(value);
}
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function getLastPathSegment(pathStr) {
    const lastForwardSlash = pathStr.lastIndexOf("/");
    const lastBackSlash = pathStr.lastIndexOf("\\");
    const lastSlashIndex = Math.max(lastForwardSlash, lastBackSlash);
    return lastSlashIndex >= 0 ? pathStr.substring(lastSlashIndex + 1) : pathStr;
}
function streamToBuffer(stream) {
    return __awaiter(this, void 0, void 0, function*() {
        var _a, stream_1, stream_1_1;
        var _b, e_1, _c, _d;
        if (index_js_1.RUNTIME.type === "node") {
            const { Readable } = yield Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[externals]/stream [external] (stream, cjs)")));
            if (stream instanceof Readable) {
                const chunks = [];
                try {
                    for(_a = true, stream_1 = __asyncValues(stream); stream_1_1 = yield stream_1.next(), _b = stream_1_1.done, !_b; _a = true){
                        _d = stream_1_1.value;
                        _a = false;
                        const chunk = _d;
                        chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (!_a && !_b && (_c = stream_1.return)) yield _c.call(stream_1);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                return Buffer.concat(chunks);
            }
        }
        if (isReadableStream(stream)) {
            const reader = stream.getReader();
            const chunks = [];
            try {
                while(true){
                    const { done, value } = yield reader.read();
                    if (done) break;
                    chunks.push(value);
                }
            } finally{
                reader.releaseLock();
            }
            const totalLength = chunks.reduce((sum, chunk)=>sum + chunk.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks){
                result.set(chunk, offset);
                offset += chunk.length;
            }
            return Buffer.from(result);
        }
        throw new Error("Unsupported stream type: " + typeof stream + ". Expected Node.js Readable stream or Web ReadableStream.");
    });
}
function newFormData() {
    return __awaiter(this, void 0, void 0, function*() {
        return new FormDataWrapper();
    });
}
class FormDataWrapper {
    constructor(){
        this.fd = new FormData();
    }
    setup() {
        return __awaiter(this, void 0, void 0, function*() {
        // noop
        });
    }
    append(key, value) {
        this.fd.append(key, String(value));
    }
    getFileName(value, filename) {
        if (filename != null) {
            return filename;
        }
        if (isNamedValue(value)) {
            return value.name;
        }
        if (isPathedValue(value) && value.path) {
            return getLastPathSegment(value.path.toString());
        }
        return undefined;
    }
    convertToBlob(value) {
        return __awaiter(this, void 0, void 0, function*() {
            if (isStreamLike(value) || isReadableStream(value)) {
                const buffer = yield streamToBuffer(value);
                return new Blob([
                    buffer
                ]);
            }
            if (value instanceof Blob) {
                return value;
            }
            if (isBuffer(value)) {
                return new Blob([
                    value
                ]);
            }
            if (value instanceof ArrayBuffer) {
                return new Blob([
                    value
                ]);
            }
            if (isArrayBufferView(value)) {
                return new Blob([
                    value
                ]);
            }
            if (typeof value === "string") {
                return new Blob([
                    value
                ]);
            }
            if (typeof value === "object" && value !== null) {
                return new Blob([
                    (0, json_js_1.toJson)(value)
                ], {
                    type: "application/json"
                });
            }
            return new Blob([
                String(value)
            ]);
        });
    }
    appendFile(key, value, fileName) {
        return __awaiter(this, void 0, void 0, function*() {
            fileName = this.getFileName(value, fileName);
            const blob = yield this.convertToBlob(value);
            if (fileName) {
                this.fd.append(key, blob, fileName);
            } else {
                this.fd.append(key, blob);
            }
        });
    }
    getRequest() {
        return {
            body: this.fd,
            headers: {},
            duplex: "half"
        };
    }
}
exports.FormDataWrapper = FormDataWrapper;
}}),
"[project]/node_modules/hume/core/form-data-utils/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeAsFormParameter = void 0;
var encodeAsFormParameter_1 = __turbopack_context__.r("[project]/node_modules/hume/core/form-data-utils/encodeAsFormParameter.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "encodeAsFormParameter", {
    enumerable: true,
    get: function() {
        return encodeAsFormParameter_1.encodeAsFormParameter;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/form-data-utils/FormDataWrapper.js [app-rsc] (ecmascript)"), exports);
}}),
"[project]/node_modules/hume/core/file.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
}}),
"[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SchemaType = void 0;
exports.SchemaType = {
    BIGINT: "bigint",
    DATE: "date",
    ENUM: "enum",
    LIST: "list",
    STRING_LITERAL: "stringLiteral",
    BOOLEAN_LITERAL: "booleanLiteral",
    OBJECT: "object",
    ANY: "any",
    BOOLEAN: "boolean",
    NUMBER: "number",
    STRING: "string",
    UNKNOWN: "unknown",
    RECORD: "record",
    SET: "set",
    UNION: "union",
    UNDISCRIMINATED_UNION: "undiscriminatedUnion",
    NULLABLE: "nullable",
    OPTIONAL: "optional",
    OPTIONAL_NULLABLE: "optionalNullable"
};
}}),
"[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getErrorMessageForIncorrectType = getErrorMessageForIncorrectType;
function getErrorMessageForIncorrectType(value, expectedType) {
    return `Expected ${expectedType}. Received ${getTypeAsString(value)}.`;
}
function getTypeAsString(value) {
    if (Array.isArray(value)) {
        return "list";
    }
    if (value === null) {
        return "null";
    }
    if (value instanceof BigInt) {
        return "BigInt";
    }
    switch(typeof value){
        case "string":
            return `"${value}"`;
        case "bigint":
        case "number":
        case "boolean":
        case "undefined":
            return `${value}`;
    }
    return typeof value;
}
}}),
"[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.maybeSkipValidation = maybeSkipValidation;
function maybeSkipValidation(schema) {
    return Object.assign(Object.assign({}, schema), {
        json: transformAndMaybeSkipValidation(schema.json),
        parse: transformAndMaybeSkipValidation(schema.parse)
    });
}
function transformAndMaybeSkipValidation(transform) {
    return (value, opts)=>{
        const transformed = transform(value, opts);
        const { skipValidation = false } = opts !== null && opts !== void 0 ? opts : {};
        if (!transformed.ok && skipValidation) {
            // eslint-disable-next-line no-console
            console.warn([
                "Failed to validate.",
                ...transformed.errors.map((error)=>"  - " + (error.path.length > 0 ? `${error.path.join(".")}: ${error.message}` : error.message))
            ].join("\n"));
            return {
                ok: true,
                value: value
            };
        } else {
            return transformed;
        }
    };
}
}}),
"[project]/node_modules/hume/core/schemas/builders/schema-utils/stringifyValidationErrors.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringifyValidationError = stringifyValidationError;
function stringifyValidationError(error) {
    if (error.path.length === 0) {
        return error.message;
    }
    return `${error.path.join(" -> ")}: ${error.message}`;
}
}}),
"[project]/node_modules/hume/core/schemas/builders/schema-utils/JsonError.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JsonError = void 0;
const stringifyValidationErrors_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/stringifyValidationErrors.js [app-rsc] (ecmascript)");
class JsonError extends Error {
    constructor(errors){
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, JsonError.prototype);
    }
}
exports.JsonError = JsonError;
}}),
"[project]/node_modules/hume/core/schemas/builders/schema-utils/ParseError.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParseError = void 0;
const stringifyValidationErrors_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/stringifyValidationErrors.js [app-rsc] (ecmascript)");
class ParseError extends Error {
    constructor(errors){
        super(errors.map(stringifyValidationErrors_1.stringifyValidationError).join("; "));
        this.errors = errors;
        Object.setPrototypeOf(this, ParseError.prototype);
    }
}
exports.ParseError = ParseError;
}}),
"[project]/node_modules/hume/core/schemas/builders/schema-utils/getSchemaUtils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSchemaUtils = getSchemaUtils;
exports.nullable = nullable;
exports.optional = optional;
exports.optionalNullable = optionalNullable;
exports.transform = transform;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const JsonError_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/JsonError.js [app-rsc] (ecmascript)");
const ParseError_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/ParseError.js [app-rsc] (ecmascript)");
function getSchemaUtils(schema) {
    return {
        nullable: ()=>nullable(schema),
        optional: ()=>optional(schema),
        optionalNullable: ()=>optionalNullable(schema),
        transform: (transformer)=>transform(schema, transformer),
        parseOrThrow: (raw, opts)=>{
            const parsed = schema.parse(raw, opts);
            if (parsed.ok) {
                return parsed.value;
            }
            throw new ParseError_1.ParseError(parsed.errors);
        },
        jsonOrThrow: (parsed, opts)=>{
            const raw = schema.json(parsed, opts);
            if (raw.ok) {
                return raw.value;
            }
            throw new JsonError_1.JsonError(raw.errors);
        }
    };
}
/**
 * schema utils are defined in one file to resolve issues with circular imports
 */ function nullable(schema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            if (raw == null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts)=>{
            if (parsed == null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.json(parsed, opts);
        },
        getType: ()=>Schema_1.SchemaType.NULLABLE
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
function optional(schema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            if (raw == null) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts)=>{
            if ((opts === null || opts === void 0 ? void 0 : opts.omitUndefined) && parsed === undefined) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            if (parsed == null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.json(parsed, opts);
        },
        getType: ()=>Schema_1.SchemaType.OPTIONAL
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
function optionalNullable(schema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            if (raw === undefined) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            if (raw === null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.parse(raw, opts);
        },
        json: (parsed, opts)=>{
            if (parsed === undefined) {
                return {
                    ok: true,
                    value: undefined
                };
            }
            if (parsed === null) {
                return {
                    ok: true,
                    value: null
                };
            }
            return schema.json(parsed, opts);
        },
        getType: ()=>Schema_1.SchemaType.OPTIONAL_NULLABLE
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
function transform(schema, transformer) {
    const baseSchema = {
        parse: (raw, opts)=>{
            const parsed = schema.parse(raw, opts);
            if (!parsed.ok) {
                return parsed;
            }
            return {
                ok: true,
                value: transformer.transform(parsed.value)
            };
        },
        json: (transformed, opts)=>{
            const parsed = transformer.untransform(transformed);
            return schema.json(parsed, opts);
        },
        getType: ()=>schema.getType()
    };
    return Object.assign(Object.assign({}, baseSchema), getSchemaUtils(baseSchema));
}
}}),
"[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParseError = exports.JsonError = exports.transform = exports.optional = exports.getSchemaUtils = void 0;
var getSchemaUtils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/getSchemaUtils.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getSchemaUtils", {
    enumerable: true,
    get: function() {
        return getSchemaUtils_1.getSchemaUtils;
    }
});
Object.defineProperty(exports, "optional", {
    enumerable: true,
    get: function() {
        return getSchemaUtils_1.optional;
    }
});
Object.defineProperty(exports, "transform", {
    enumerable: true,
    get: function() {
        return getSchemaUtils_1.transform;
    }
});
var JsonError_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/JsonError.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "JsonError", {
    enumerable: true,
    get: function() {
        return JsonError_1.JsonError;
    }
});
var ParseError_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/ParseError.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "ParseError", {
    enumerable: true,
    get: function() {
        return ParseError_1.ParseError;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/bigint/bigint.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigint = bigint;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function bigint() {
    const baseSchema = {
        parse: (raw, { breadcrumbsPrefix = [] } = {})=>{
            if (typeof raw === "bigint") {
                return {
                    ok: true,
                    value: raw
                };
            }
            if (typeof raw === "number") {
                return {
                    ok: true,
                    value: BigInt(raw)
                };
            }
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "bigint | number")
                    }
                ]
            };
        },
        json: (bigint, { breadcrumbsPrefix = [] } = {})=>{
            if (typeof bigint !== "bigint") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(bigint, "bigint")
                        }
                    ]
                };
            }
            return {
                ok: true,
                value: bigint
            };
        },
        getType: ()=>Schema_1.SchemaType.BIGINT
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
}}),
"[project]/node_modules/hume/core/schemas/builders/bigint/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bigint = void 0;
var bigint_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/bigint/bigint.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "bigint", {
    enumerable: true,
    get: function() {
        return bigint_1.bigint;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/date/date.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.date = date;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
// https://stackoverflow.com/questions/12756159/regex-and-iso8601-formatted-datetime
const ISO_8601_REGEX = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
function date() {
    const baseSchema = {
        parse: (raw, { breadcrumbsPrefix = [] } = {})=>{
            if (typeof raw !== "string") {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "string")
                        }
                    ]
                };
            }
            if (!ISO_8601_REGEX.test(raw)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(raw, "ISO 8601 date string")
                        }
                    ]
                };
            }
            return {
                ok: true,
                value: new Date(raw)
            };
        },
        json: (date, { breadcrumbsPrefix = [] } = {})=>{
            if (date instanceof Date) {
                return {
                    ok: true,
                    value: date.toISOString()
                };
            } else {
                return {
                    ok: false,
                    errors: [
                        {
                            path: breadcrumbsPrefix,
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(date, "Date object")
                        }
                    ]
                };
            }
        },
        getType: ()=>Schema_1.SchemaType.DATE
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
}}),
"[project]/node_modules/hume/core/schemas/builders/date/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.date = void 0;
var date_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/date/date.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "date", {
    enumerable: true,
    get: function() {
        return date_1.date;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createIdentitySchemaCreator = createIdentitySchemaCreator;
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
function createIdentitySchemaCreator(schemaType, validate) {
    return ()=>{
        const baseSchema = {
            parse: validate,
            json: validate,
            getType: ()=>schemaType
        };
        return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
    };
}
}}),
"[project]/node_modules/hume/core/schemas/builders/enum/enum.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.enum_ = enum_;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
function enum_(values) {
    const validValues = new Set(values);
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ENUM, (value, { allowUnrecognizedEnumValues, breadcrumbsPrefix = [] } = {})=>{
        if (typeof value !== "string") {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "string")
                    }
                ]
            };
        }
        if (!validValues.has(value) && !allowUnrecognizedEnumValues) {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "enum")
                    }
                ]
            };
        }
        return {
            ok: true,
            value: value
        };
    });
    return schemaCreator();
}
}}),
"[project]/node_modules/hume/core/schemas/builders/enum/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.enum_ = void 0;
var enum_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/enum/enum.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "enum_", {
    enumerable: true,
    get: function() {
        return enum_1.enum_;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/lazy/lazy.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazy = lazy;
exports.constructLazyBaseSchema = constructLazyBaseSchema;
exports.getMemoizedSchema = getMemoizedSchema;
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function lazy(getter) {
    const baseSchema = constructLazyBaseSchema(getter);
    return Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
function constructLazyBaseSchema(getter) {
    return {
        parse: (raw, opts)=>getMemoizedSchema(getter).parse(raw, opts),
        json: (parsed, opts)=>getMemoizedSchema(getter).json(parsed, opts),
        getType: ()=>getMemoizedSchema(getter).getType()
    };
}
function getMemoizedSchema(getter) {
    const castedGetter = getter;
    if (castedGetter.__zurg_memoized == null) {
        castedGetter.__zurg_memoized = getter();
    }
    return castedGetter.__zurg_memoized;
}
}}),
"[project]/node_modules/hume/core/schemas/utils/entries.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.entries = entries;
function entries(object) {
    return Object.entries(object);
}
}}),
"[project]/node_modules/hume/core/schemas/utils/filterObject.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.filterObject = filterObject;
function filterObject(obj, keysToInclude) {
    const keysToIncludeSet = new Set(keysToInclude);
    return Object.entries(obj).reduce((acc, [key, value])=>{
        if (keysToIncludeSet.has(key)) {
            acc[key] = value;
        }
        return acc;
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    }, {});
}
}}),
"[project]/node_modules/hume/core/schemas/utils/isPlainObject.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isPlainObject = isPlainObject;
// borrowed from https://github.com/lodash/lodash/blob/master/isPlainObject.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    let proto = value;
    while(Object.getPrototypeOf(proto) !== null){
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
}
}}),
"[project]/node_modules/hume/core/schemas/utils/keys.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.keys = keys;
function keys(object) {
    return Object.keys(object);
}
}}),
"[project]/node_modules/hume/core/schemas/utils/partition.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.partition = partition;
function partition(items, predicate) {
    const trueItems = [], falseItems = [];
    for (const item of items){
        if (predicate(item)) {
            trueItems.push(item);
        } else {
            falseItems.push(item);
        }
    }
    return [
        trueItems,
        falseItems
    ];
}
}}),
"[project]/node_modules/hume/core/schemas/builders/object-like/getObjectLikeUtils.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getObjectLikeUtils = getObjectLikeUtils;
exports.withParsedProperties = withParsedProperties;
const filterObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/filterObject.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/isPlainObject.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function getObjectLikeUtils(schema) {
    return {
        withParsedProperties: (properties)=>withParsedProperties(schema, properties)
    };
}
/**
 * object-like utils are defined in one file to resolve issues with circular imports
 */ function withParsedProperties(objectLike, properties) {
    const objectSchema = {
        parse: (raw, opts)=>{
            const parsedObject = objectLike.parse(raw, opts);
            if (!parsedObject.ok) {
                return parsedObject;
            }
            const additionalProperties = Object.entries(properties).reduce((processed, [key, value])=>{
                return Object.assign(Object.assign({}, processed), {
                    [key]: typeof value === "function" ? value(parsedObject.value) : value
                });
            }, {});
            return {
                ok: true,
                value: Object.assign(Object.assign({}, parsedObject.value), additionalProperties)
            };
        },
        json: (parsed, opts)=>{
            var _a;
            if (!(0, isPlainObject_1.isPlainObject)(parsed)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, "object")
                        }
                    ]
                };
            }
            // strip out added properties
            const addedPropertyKeys = new Set(Object.keys(properties));
            const parsedWithoutAddedProperties = (0, filterObject_1.filterObject)(parsed, Object.keys(parsed).filter((key)=>!addedPropertyKeys.has(key)));
            return objectLike.json(parsedWithoutAddedProperties, opts);
        },
        getType: ()=>objectLike.getType()
    };
    return Object.assign(Object.assign(Object.assign({}, objectSchema), (0, schema_utils_1.getSchemaUtils)(objectSchema)), getObjectLikeUtils(objectSchema));
}
}}),
"[project]/node_modules/hume/core/schemas/builders/object-like/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withParsedProperties = exports.getObjectLikeUtils = void 0;
var getObjectLikeUtils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object-like/getObjectLikeUtils.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getObjectLikeUtils", {
    enumerable: true,
    get: function() {
        return getObjectLikeUtils_1.getObjectLikeUtils;
    }
});
Object.defineProperty(exports, "withParsedProperties", {
    enumerable: true,
    get: function() {
        return getObjectLikeUtils_1.withParsedProperties;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/object/property.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.property = property;
exports.isProperty = isProperty;
function property(rawKey, valueSchema) {
    return {
        rawKey,
        valueSchema,
        isProperty: true
    };
}
function isProperty(maybeProperty) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    return maybeProperty.isProperty;
}
}}),
"[project]/node_modules/hume/core/schemas/builders/object/object.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.object = object;
exports.getObjectUtils = getObjectUtils;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const entries_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/entries.js [app-rsc] (ecmascript)");
const filterObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/filterObject.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/isPlainObject.js [app-rsc] (ecmascript)");
const keys_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/keys.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const partition_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/partition.js [app-rsc] (ecmascript)");
const object_like_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object-like/index.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
const property_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/property.js [app-rsc] (ecmascript)");
function object(schemas) {
    const baseSchema = {
        _getRawProperties: ()=>Object.entries(schemas).map(([parsedKey, propertySchema])=>(0, property_1.isProperty)(propertySchema) ? propertySchema.rawKey : parsedKey),
        _getParsedProperties: ()=>(0, keys_1.keys)(schemas),
        parse: (raw, opts)=>{
            const rawKeyToProperty = {};
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)){
                const rawKey = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
                const property = {
                    rawKey,
                    parsedKey: parsedKey,
                    valueSchema
                };
                rawKeyToProperty[rawKey] = property;
                if (isSchemaRequired(valueSchema)) {
                    requiredKeys.push(rawKey);
                }
            }
            return validateAndTransformObject({
                value: raw,
                requiredKeys,
                getProperty: (rawKey)=>{
                    const property = rawKeyToProperty[rawKey];
                    if (property == null) {
                        return undefined;
                    }
                    return {
                        transformedKey: property.parsedKey,
                        transform: (propertyValue)=>{
                            var _a;
                            return property.valueSchema.parse(propertyValue, Object.assign(Object.assign({}, opts), {
                                breadcrumbsPrefix: [
                                    ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                                    rawKey
                                ]
                            }));
                        }
                    };
                },
                unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
                skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
                omitUndefined: opts === null || opts === void 0 ? void 0 : opts.omitUndefined
            });
        },
        json: (parsed, opts)=>{
            const requiredKeys = [];
            for (const [parsedKey, schemaOrObjectProperty] of (0, entries_1.entries)(schemas)){
                const valueSchema = (0, property_1.isProperty)(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty;
                if (isSchemaRequired(valueSchema)) {
                    requiredKeys.push(parsedKey);
                }
            }
            return validateAndTransformObject({
                value: parsed,
                requiredKeys,
                getProperty: (parsedKey)=>{
                    const property = schemas[parsedKey];
                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                    if (property == null) {
                        return undefined;
                    }
                    if ((0, property_1.isProperty)(property)) {
                        return {
                            transformedKey: property.rawKey,
                            transform: (propertyValue)=>{
                                var _a;
                                return property.valueSchema.json(propertyValue, Object.assign(Object.assign({}, opts), {
                                    breadcrumbsPrefix: [
                                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                                        parsedKey
                                    ]
                                }));
                            }
                        };
                    } else {
                        return {
                            transformedKey: parsedKey,
                            transform: (propertyValue)=>{
                                var _a;
                                return property.json(propertyValue, Object.assign(Object.assign({}, opts), {
                                    breadcrumbsPrefix: [
                                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                                        parsedKey
                                    ]
                                }));
                            }
                        };
                    }
                },
                unrecognizedObjectKeys: opts === null || opts === void 0 ? void 0 : opts.unrecognizedObjectKeys,
                skipValidation: opts === null || opts === void 0 ? void 0 : opts.skipValidation,
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix,
                omitUndefined: opts === null || opts === void 0 ? void 0 : opts.omitUndefined
            });
        },
        getType: ()=>Schema_1.SchemaType.OBJECT
    };
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
}
function validateAndTransformObject({ value, requiredKeys, getProperty, unrecognizedObjectKeys = "fail", skipValidation = false, breadcrumbsPrefix = [] }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
                }
            ]
        };
    }
    const missingRequiredKeys = new Set(requiredKeys);
    const errors = [];
    const transformed = {};
    for (const [preTransformedKey, preTransformedItemValue] of Object.entries(value)){
        const property = getProperty(preTransformedKey);
        if (property != null) {
            missingRequiredKeys.delete(preTransformedKey);
            const value = property.transform(preTransformedItemValue);
            if (value.ok) {
                transformed[property.transformedKey] = value.value;
            } else {
                transformed[preTransformedKey] = preTransformedItemValue;
                errors.push(...value.errors);
            }
        } else {
            switch(unrecognizedObjectKeys){
                case "fail":
                    errors.push({
                        path: [
                            ...breadcrumbsPrefix,
                            preTransformedKey
                        ],
                        message: `Unexpected key "${preTransformedKey}"`
                    });
                    break;
                case "strip":
                    break;
                case "passthrough":
                    transformed[preTransformedKey] = preTransformedItemValue;
                    break;
            }
        }
    }
    errors.push(...requiredKeys.filter((key)=>missingRequiredKeys.has(key)).map((key)=>({
            path: breadcrumbsPrefix,
            message: `Missing required key "${key}"`
        })));
    if (errors.length === 0 || skipValidation) {
        return {
            ok: true,
            value: transformed
        };
    } else {
        return {
            ok: false,
            errors
        };
    }
}
function getObjectUtils(schema) {
    return {
        extend: (extension)=>{
            const baseSchema = {
                _getParsedProperties: ()=>[
                        ...schema._getParsedProperties(),
                        ...extension._getParsedProperties()
                    ],
                _getRawProperties: ()=>[
                        ...schema._getRawProperties(),
                        ...extension._getRawProperties()
                    ],
                parse: (raw, opts)=>{
                    return validateAndTransformExtendedObject({
                        extensionKeys: extension._getRawProperties(),
                        value: raw,
                        transformBase: (rawBase)=>schema.parse(rawBase, opts),
                        transformExtension: (rawExtension)=>extension.parse(rawExtension, opts)
                    });
                },
                json: (parsed, opts)=>{
                    return validateAndTransformExtendedObject({
                        extensionKeys: extension._getParsedProperties(),
                        value: parsed,
                        transformBase: (parsedBase)=>schema.json(parsedBase, opts),
                        transformExtension: (parsedExtension)=>extension.json(parsedExtension, opts)
                    });
                },
                getType: ()=>Schema_1.SchemaType.OBJECT
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        },
        passthrough: ()=>{
            const baseSchema = {
                _getParsedProperties: ()=>schema._getParsedProperties(),
                _getRawProperties: ()=>schema._getRawProperties(),
                parse: (raw, opts)=>{
                    const transformed = schema.parse(raw, Object.assign(Object.assign({}, opts), {
                        unrecognizedObjectKeys: "passthrough"
                    }));
                    if (!transformed.ok) {
                        return transformed;
                    }
                    return {
                        ok: true,
                        value: Object.assign(Object.assign({}, raw), transformed.value)
                    };
                },
                json: (parsed, opts)=>{
                    const transformed = schema.json(parsed, Object.assign(Object.assign({}, opts), {
                        unrecognizedObjectKeys: "passthrough"
                    }));
                    if (!transformed.ok) {
                        return transformed;
                    }
                    return {
                        ok: true,
                        value: Object.assign(Object.assign({}, parsed), transformed.value)
                    };
                },
                getType: ()=>Schema_1.SchemaType.OBJECT
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), getObjectUtils(baseSchema));
        }
    };
}
function validateAndTransformExtendedObject({ extensionKeys, value, transformBase, transformExtension }) {
    const extensionPropertiesSet = new Set(extensionKeys);
    const [extensionProperties, baseProperties] = (0, partition_1.partition)((0, keys_1.keys)(value), (key)=>extensionPropertiesSet.has(key));
    const transformedBase = transformBase((0, filterObject_1.filterObject)(value, baseProperties));
    const transformedExtension = transformExtension((0, filterObject_1.filterObject)(value, extensionProperties));
    if (transformedBase.ok && transformedExtension.ok) {
        return {
            ok: true,
            value: Object.assign(Object.assign({}, transformedBase.value), transformedExtension.value)
        };
    } else {
        return {
            ok: false,
            errors: [
                ...transformedBase.ok ? [] : transformedBase.errors,
                ...transformedExtension.ok ? [] : transformedExtension.errors
            ]
        };
    }
}
function isSchemaRequired(schema) {
    return !isSchemaOptional(schema);
}
function isSchemaOptional(schema) {
    switch(schema.getType()){
        case Schema_1.SchemaType.ANY:
        case Schema_1.SchemaType.UNKNOWN:
        case Schema_1.SchemaType.OPTIONAL:
        case Schema_1.SchemaType.OPTIONAL_NULLABLE:
            return true;
        default:
            return false;
    }
}
}}),
"[project]/node_modules/hume/core/schemas/builders/object/objectWithoutOptionalProperties.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.objectWithoutOptionalProperties = objectWithoutOptionalProperties;
const object_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/object.js [app-rsc] (ecmascript)");
function objectWithoutOptionalProperties(schemas) {
    return (0, object_1.object)(schemas);
}
}}),
"[project]/node_modules/hume/core/schemas/builders/object/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.property = exports.isProperty = exports.objectWithoutOptionalProperties = exports.object = exports.getObjectUtils = void 0;
var object_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/object.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getObjectUtils", {
    enumerable: true,
    get: function() {
        return object_1.getObjectUtils;
    }
});
Object.defineProperty(exports, "object", {
    enumerable: true,
    get: function() {
        return object_1.object;
    }
});
var objectWithoutOptionalProperties_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/objectWithoutOptionalProperties.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "objectWithoutOptionalProperties", {
    enumerable: true,
    get: function() {
        return objectWithoutOptionalProperties_1.objectWithoutOptionalProperties;
    }
});
var property_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/property.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "isProperty", {
    enumerable: true,
    get: function() {
        return property_1.isProperty;
    }
});
Object.defineProperty(exports, "property", {
    enumerable: true,
    get: function() {
        return property_1.property;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/lazy/lazyObject.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazyObject = lazyObject;
const object_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/index.js [app-rsc] (ecmascript)");
const object_like_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object-like/index.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
const lazy_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/lazy/lazy.js [app-rsc] (ecmascript)");
function lazyObject(getter) {
    const baseSchema = Object.assign(Object.assign({}, (0, lazy_1.constructLazyBaseSchema)(getter)), {
        _getRawProperties: ()=>(0, lazy_1.getMemoizedSchema)(getter)._getRawProperties(),
        _getParsedProperties: ()=>(0, lazy_1.getMemoizedSchema)(getter)._getParsedProperties()
    });
    return Object.assign(Object.assign(Object.assign(Object.assign({}, baseSchema), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema)), (0, object_1.getObjectUtils)(baseSchema));
}
}}),
"[project]/node_modules/hume/core/schemas/builders/lazy/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazyObject = exports.lazy = void 0;
var lazy_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/lazy/lazy.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "lazy", {
    enumerable: true,
    get: function() {
        return lazy_1.lazy;
    }
});
var lazyObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/lazy/lazyObject.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "lazyObject", {
    enumerable: true,
    get: function() {
        return lazyObject_1.lazyObject;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/list/list.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.list = list;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function list(schema) {
    const baseSchema = {
        parse: (raw, opts)=>validateAndTransformArray(raw, (item, index)=>{
                var _a;
                return schema.parse(item, Object.assign(Object.assign({}, opts), {
                    breadcrumbsPrefix: [
                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                        `[${index}]`
                    ]
                }));
            }),
        json: (parsed, opts)=>validateAndTransformArray(parsed, (item, index)=>{
                var _a;
                return schema.json(item, Object.assign(Object.assign({}, opts), {
                    breadcrumbsPrefix: [
                        ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                        `[${index}]`
                    ]
                }));
            }),
        getType: ()=>Schema_1.SchemaType.LIST
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
function validateAndTransformArray(value, transformItem) {
    if (!Array.isArray(value)) {
        return {
            ok: false,
            errors: [
                {
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "list"),
                    path: []
                }
            ]
        };
    }
    const maybeValidItems = value.map((item, index)=>transformItem(item, index));
    return maybeValidItems.reduce((acc, item)=>{
        if (acc.ok && item.ok) {
            return {
                ok: true,
                value: [
                    ...acc.value,
                    item.value
                ]
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!item.ok) {
            errors.push(...item.errors);
        }
        return {
            ok: false,
            errors
        };
    }, {
        ok: true,
        value: []
    });
}
}}),
"[project]/node_modules/hume/core/schemas/builders/list/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.list = void 0;
var list_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/list/list.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "list", {
    enumerable: true,
    get: function() {
        return list_1.list;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/literals/stringLiteral.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringLiteral = stringLiteral;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
function stringLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING_LITERAL, (value, { breadcrumbsPrefix = [] } = {})=>{
        if (value === literal) {
            return {
                ok: true,
                value: literal
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, `"${literal}"`)
                    }
                ]
            };
        }
    });
    return schemaCreator();
}
}}),
"[project]/node_modules/hume/core/schemas/builders/literals/booleanLiteral.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.booleanLiteral = booleanLiteral;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
function booleanLiteral(literal) {
    const schemaCreator = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN_LITERAL, (value, { breadcrumbsPrefix = [] } = {})=>{
        if (value === literal) {
            return {
                ok: true,
                value: literal
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: breadcrumbsPrefix,
                        message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, `${literal.toString()}`)
                    }
                ]
            };
        }
    });
    return schemaCreator();
}
}}),
"[project]/node_modules/hume/core/schemas/builders/literals/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.booleanLiteral = exports.stringLiteral = void 0;
var stringLiteral_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/literals/stringLiteral.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "stringLiteral", {
    enumerable: true,
    get: function() {
        return stringLiteral_1.stringLiteral;
    }
});
var booleanLiteral_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/literals/booleanLiteral.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "booleanLiteral", {
    enumerable: true,
    get: function() {
        return booleanLiteral_1.booleanLiteral;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/primitives/any.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.any = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
exports.any = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.ANY, (value)=>({
        ok: true,
        value
    }));
}}),
"[project]/node_modules/hume/core/schemas/builders/primitives/boolean.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.boolean = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
exports.boolean = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.BOOLEAN, (value, { breadcrumbsPrefix = [] } = {})=>{
    if (typeof value === "boolean") {
        return {
            ok: true,
            value
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "boolean")
                }
            ]
        };
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/primitives/number.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.number = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
exports.number = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.NUMBER, (value, { breadcrumbsPrefix = [] } = {})=>{
    if (typeof value === "number") {
        return {
            ok: true,
            value
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "number")
                }
            ]
        };
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/primitives/string.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.string = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
exports.string = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.STRING, (value, { breadcrumbsPrefix = [] } = {})=>{
    if (typeof value === "string") {
        return {
            ok: true,
            value
        };
    } else {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "string")
                }
            ]
        };
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/primitives/unknown.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknown = void 0;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const createIdentitySchemaCreator_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/createIdentitySchemaCreator.js [app-rsc] (ecmascript)");
exports.unknown = (0, createIdentitySchemaCreator_1.createIdentitySchemaCreator)(Schema_1.SchemaType.UNKNOWN, (value)=>({
        ok: true,
        value
    }));
}}),
"[project]/node_modules/hume/core/schemas/builders/primitives/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknown = exports.string = exports.number = exports.boolean = exports.any = void 0;
var any_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/primitives/any.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "any", {
    enumerable: true,
    get: function() {
        return any_1.any;
    }
});
var boolean_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/primitives/boolean.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "boolean", {
    enumerable: true,
    get: function() {
        return boolean_1.boolean;
    }
});
var number_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/primitives/number.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "number", {
    enumerable: true,
    get: function() {
        return number_1.number;
    }
});
var string_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/primitives/string.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "string", {
    enumerable: true,
    get: function() {
        return string_1.string;
    }
});
var unknown_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/primitives/unknown.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "unknown", {
    enumerable: true,
    get: function() {
        return unknown_1.unknown;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/record/record.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.record = record;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const entries_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/entries.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/isPlainObject.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function record(keySchema, valueSchema) {
    const baseSchema = {
        parse: (raw, opts)=>{
            return validateAndTransformRecord({
                value: raw,
                isKeyNumeric: keySchema.getType() === Schema_1.SchemaType.NUMBER,
                transformKey: (key)=>{
                    var _a;
                    return keySchema.parse(key, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key} (key)`
                        ]
                    }));
                },
                transformValue: (value, key)=>{
                    var _a;
                    return valueSchema.parse(value, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key}`
                        ]
                    }));
                },
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        json: (parsed, opts)=>{
            return validateAndTransformRecord({
                value: parsed,
                isKeyNumeric: keySchema.getType() === Schema_1.SchemaType.NUMBER,
                transformKey: (key)=>{
                    var _a;
                    return keySchema.json(key, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key} (key)`
                        ]
                    }));
                },
                transformValue: (value, key)=>{
                    var _a;
                    return valueSchema.json(value, Object.assign(Object.assign({}, opts), {
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            `${key}`
                        ]
                    }));
                },
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        getType: ()=>Schema_1.SchemaType.RECORD
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
function validateAndTransformRecord({ value, isKeyNumeric, transformKey, transformValue, breadcrumbsPrefix = [] }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
                }
            ]
        };
    }
    return (0, entries_1.entries)(value).reduce((accPromise, [stringKey, value])=>{
        if (value === undefined) {
            return accPromise;
        }
        const acc = accPromise;
        let key = stringKey;
        if (isKeyNumeric) {
            const numberKey = stringKey.length > 0 ? Number(stringKey) : NaN;
            if (!isNaN(numberKey)) {
                key = numberKey;
            }
        }
        const transformedKey = transformKey(key);
        const transformedValue = transformValue(value, key);
        if (acc.ok && transformedKey.ok && transformedValue.ok) {
            return {
                ok: true,
                value: Object.assign(Object.assign({}, acc.value), {
                    [transformedKey.value]: transformedValue.value
                })
            };
        }
        const errors = [];
        if (!acc.ok) {
            errors.push(...acc.errors);
        }
        if (!transformedKey.ok) {
            errors.push(...transformedKey.errors);
        }
        if (!transformedValue.ok) {
            errors.push(...transformedValue.errors);
        }
        return {
            ok: false,
            errors
        };
    }, {
        ok: true,
        value: {}
    });
}
}}),
"[project]/node_modules/hume/core/schemas/builders/record/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.record = void 0;
var record_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/record/record.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "record", {
    enumerable: true,
    get: function() {
        return record_1.record;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/set/set.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.set = set;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const list_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/list/index.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function set(schema) {
    const listSchema = (0, list_1.list)(schema);
    const baseSchema = {
        parse: (raw, opts)=>{
            const parsedList = listSchema.parse(raw, opts);
            if (parsedList.ok) {
                return {
                    ok: true,
                    value: new Set(parsedList.value)
                };
            } else {
                return parsedList;
            }
        },
        json: (parsed, opts)=>{
            var _a;
            if (!(parsed instanceof Set)) {
                return {
                    ok: false,
                    errors: [
                        {
                            path: (_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(parsed, "Set")
                        }
                    ]
                };
            }
            const jsonList = listSchema.json([
                ...parsed
            ], opts);
            return jsonList;
        },
        getType: ()=>Schema_1.SchemaType.SET
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
}}),
"[project]/node_modules/hume/core/schemas/builders/set/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.set = void 0;
var set_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/set/set.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "set", {
    enumerable: true,
    get: function() {
        return set_1.set;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.undiscriminatedUnion = undiscriminatedUnion;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function undiscriminatedUnion(schemas) {
    const baseSchema = {
        parse: (raw, opts)=>{
            return validateAndTransformUndiscriminatedUnion((schema, opts)=>schema.parse(raw, opts), schemas, opts);
        },
        json: (parsed, opts)=>{
            return validateAndTransformUndiscriminatedUnion((schema, opts)=>schema.json(parsed, opts), schemas, opts);
        },
        getType: ()=>Schema_1.SchemaType.UNDISCRIMINATED_UNION
    };
    return Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema));
}
function validateAndTransformUndiscriminatedUnion(transform, schemas, opts) {
    const errors = [];
    for (const [index, schema] of schemas.entries()){
        const transformed = transform(schema, Object.assign(Object.assign({}, opts), {
            skipValidation: false
        }));
        if (transformed.ok) {
            return transformed;
        } else {
            for (const error of transformed.errors){
                errors.push({
                    path: error.path,
                    message: `[Variant ${index}] ${error.message}`
                });
            }
        }
    }
    return {
        ok: false,
        errors
    };
}
}}),
"[project]/node_modules/hume/core/schemas/builders/undiscriminated-union/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.undiscriminatedUnion = void 0;
var undiscriminatedUnion_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/undiscriminated-union/undiscriminatedUnion.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "undiscriminatedUnion", {
    enumerable: true,
    get: function() {
        return undiscriminatedUnion_1.undiscriminatedUnion;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/union/discriminant.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.discriminant = discriminant;
function discriminant(parsedDiscriminant, rawDiscriminant) {
    return {
        parsedDiscriminant,
        rawDiscriminant
    };
}
}}),
"[project]/node_modules/hume/core/schemas/builders/union/union.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __rest = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.union = union;
const Schema_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/Schema.js [app-rsc] (ecmascript)");
const getErrorMessageForIncorrectType_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/getErrorMessageForIncorrectType.js [app-rsc] (ecmascript)");
const isPlainObject_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/isPlainObject.js [app-rsc] (ecmascript)");
const keys_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/keys.js [app-rsc] (ecmascript)");
const maybeSkipValidation_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/utils/maybeSkipValidation.js [app-rsc] (ecmascript)");
const enum_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/enum/index.js [app-rsc] (ecmascript)");
const object_like_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object-like/index.js [app-rsc] (ecmascript)");
const schema_utils_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)");
function union(discriminant, union) {
    const rawDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.rawDiscriminant;
    const parsedDiscriminant = typeof discriminant === "string" ? discriminant : discriminant.parsedDiscriminant;
    const discriminantValueSchema = (0, enum_1.enum_)((0, keys_1.keys)(union));
    const baseSchema = {
        parse: (raw, opts)=>{
            return transformAndValidateUnion({
                value: raw,
                discriminant: rawDiscriminant,
                transformedDiscriminant: parsedDiscriminant,
                transformDiscriminantValue: (discriminantValue)=>{
                    var _a;
                    return discriminantValueSchema.parse(discriminantValue, {
                        allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            rawDiscriminant
                        ]
                    });
                },
                getAdditionalPropertiesSchema: (discriminantValue)=>union[discriminantValue],
                allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema)=>additionalPropertiesSchema.parse(additionalProperties, opts),
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        json: (parsed, opts)=>{
            return transformAndValidateUnion({
                value: parsed,
                discriminant: parsedDiscriminant,
                transformedDiscriminant: rawDiscriminant,
                transformDiscriminantValue: (discriminantValue)=>{
                    var _a;
                    return discriminantValueSchema.json(discriminantValue, {
                        allowUnrecognizedEnumValues: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                        breadcrumbsPrefix: [
                            ...(_a = opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix) !== null && _a !== void 0 ? _a : [],
                            parsedDiscriminant
                        ]
                    });
                },
                getAdditionalPropertiesSchema: (discriminantValue)=>union[discriminantValue],
                allowUnrecognizedUnionMembers: opts === null || opts === void 0 ? void 0 : opts.allowUnrecognizedUnionMembers,
                transformAdditionalProperties: (additionalProperties, additionalPropertiesSchema)=>additionalPropertiesSchema.json(additionalProperties, opts),
                breadcrumbsPrefix: opts === null || opts === void 0 ? void 0 : opts.breadcrumbsPrefix
            });
        },
        getType: ()=>Schema_1.SchemaType.UNION
    };
    return Object.assign(Object.assign(Object.assign({}, (0, maybeSkipValidation_1.maybeSkipValidation)(baseSchema)), (0, schema_utils_1.getSchemaUtils)(baseSchema)), (0, object_like_1.getObjectLikeUtils)(baseSchema));
}
function transformAndValidateUnion({ value, discriminant, transformedDiscriminant, transformDiscriminantValue, getAdditionalPropertiesSchema, allowUnrecognizedUnionMembers = false, transformAdditionalProperties, breadcrumbsPrefix = [] }) {
    if (!(0, isPlainObject_1.isPlainObject)(value)) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: (0, getErrorMessageForIncorrectType_1.getErrorMessageForIncorrectType)(value, "object")
                }
            ]
        };
    }
    const _a = value, _b = discriminant, discriminantValue = _a[_b], additionalProperties = __rest(_a, [
        typeof _b === "symbol" ? _b : _b + ""
    ]);
    if (discriminantValue == null) {
        return {
            ok: false,
            errors: [
                {
                    path: breadcrumbsPrefix,
                    message: `Missing discriminant ("${discriminant}")`
                }
            ]
        };
    }
    const transformedDiscriminantValue = transformDiscriminantValue(discriminantValue);
    if (!transformedDiscriminantValue.ok) {
        return {
            ok: false,
            errors: transformedDiscriminantValue.errors
        };
    }
    const additionalPropertiesSchema = getAdditionalPropertiesSchema(transformedDiscriminantValue.value);
    if (additionalPropertiesSchema == null) {
        if (allowUnrecognizedUnionMembers) {
            return {
                ok: true,
                value: Object.assign({
                    [transformedDiscriminant]: transformedDiscriminantValue.value
                }, additionalProperties)
            };
        } else {
            return {
                ok: false,
                errors: [
                    {
                        path: [
                            ...breadcrumbsPrefix,
                            discriminant
                        ],
                        message: "Unexpected discriminant value"
                    }
                ]
            };
        }
    }
    const transformedAdditionalProperties = transformAdditionalProperties(additionalProperties, additionalPropertiesSchema);
    if (!transformedAdditionalProperties.ok) {
        return transformedAdditionalProperties;
    }
    return {
        ok: true,
        value: Object.assign({
            [transformedDiscriminant]: discriminantValue
        }, transformedAdditionalProperties.value)
    };
}
}}),
"[project]/node_modules/hume/core/schemas/builders/union/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.union = exports.discriminant = void 0;
var discriminant_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/union/discriminant.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "discriminant", {
    enumerable: true,
    get: function() {
        return discriminant_1.discriminant;
    }
});
var union_1 = __turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/union/union.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "union", {
    enumerable: true,
    get: function() {
        return union_1.union;
    }
});
}}),
"[project]/node_modules/hume/core/schemas/builders/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/bigint/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/date/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/enum/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/lazy/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/list/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/literals/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/object-like/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/primitives/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/record/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/schema-utils/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/set/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/undiscriminated-union/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/union/index.js [app-rsc] (ecmascript)"), exports);
}}),
"[project]/node_modules/hume/core/schemas/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/builders/index.js [app-rsc] (ecmascript)"), exports);
}}),
"[project]/node_modules/hume/core/websocket/events.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CloseEvent = exports.ErrorEvent = exports.Event = void 0;
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */ class Event {
    constructor(type, target){
        this.target = target;
        this.type = type;
    }
}
exports.Event = Event;
class ErrorEvent extends Event {
    constructor(error, target){
        super("error", target);
        this.message = error.message;
        this.error = error;
    }
}
exports.ErrorEvent = ErrorEvent;
class CloseEvent extends Event {
    constructor(code = 1000, reason = "", target){
        super("close", target);
        this.wasClean = true;
        this.willReconnect = false;
        this.code = code;
        this.reason = reason;
    }
}
exports.CloseEvent = CloseEvent;
}}),
"[project]/node_modules/hume/core/websocket/ws.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ReconnectingWebSocket = void 0;
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */ const runtime_1 = __turbopack_context__.r("[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)");
const Events = __importStar(__turbopack_context__.r("[project]/node_modules/hume/core/websocket/events.js [app-rsc] (ecmascript)"));
const ws_1 = __turbopack_context__.r("[project]/node_modules/ws/index.js [app-rsc] (ecmascript)");
const ABNORMAL_CLOSURE_CODE = 1006;
const getGlobalWebSocket = ()=>{
    if (typeof WebSocket !== "undefined") {
        // @ts-ignore
        return WebSocket;
    } else if (runtime_1.RUNTIME.type === "node") {
        return ws_1.WebSocket;
    }
    return undefined;
};
/**
 * Returns true if given argument looks like a WebSocket class
 */ const isWebSocket = (w)=>typeof w !== "undefined" && !!w && w.CLOSING === 2;
const DEFAULT = {
    maxReconnectionDelay: 10000,
    minReconnectionDelay: 1000 + Math.random() * 4000,
    minUptime: 5000,
    reconnectionDelayGrowFactor: 1.3,
    connectionTimeout: 4000,
    maxRetries: Infinity,
    maxEnqueuedMessages: Infinity,
    startClosed: false,
    debug: false
};
class ReconnectingWebSocket {
    constructor(url, protocols, options = {}){
        this._listeners = {
            error: [],
            message: [],
            open: [],
            close: []
        };
        this._retryCount = -1;
        this._shouldReconnect = true;
        this._connectLock = false;
        this._binaryType = "blob";
        this._closeCalled = false;
        this._messageQueue = [];
        /**
         * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
         */ this.onclose = null;
        /**
         * An event listener to be called when an error occurs
         */ this.onerror = null;
        /**
         * An event listener to be called when a message is received from the server
         */ this.onmessage = null;
        /**
         * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
         * this indicates that the connection is ready to send and receive data
         */ this.onopen = null;
        this._handleOpen = (event)=>{
            this._debug("open event");
            const { minUptime = DEFAULT.minUptime } = this._options;
            clearTimeout(this._connectTimeout);
            this._uptimeTimeout = setTimeout(()=>this._acceptOpen(), minUptime);
            this._ws.binaryType = this._binaryType;
            // send enqueued messages (messages sent before websocket open event)
            this._messageQueue.forEach((message)=>{
                var _a;
                return (_a = this._ws) === null || _a === void 0 ? void 0 : _a.send(message);
            });
            this._messageQueue = [];
            if (this.onopen) {
                this.onopen(event);
            }
            this._listeners.open.forEach((listener)=>this._callEventListener(event, listener));
        };
        this._handleMessage = (event)=>{
            this._debug("message event");
            if (this.onmessage) {
                this.onmessage(event);
            }
            this._listeners.message.forEach((listener)=>this._callEventListener(event, listener));
        };
        /**
         * Core handler for all errors. It first standardizes the error input using `_adaptError`,
         * then manages disconnection, dispatches the standardized error event, and initiates reconnection.
         * @param rawErrorOrEventInput - The error data from any internal source.
         */ this._handleError = (rawErrorOrEventInput)=>{
            this._debug("Raw error/event received by _handleError, passing to _adaptError:", rawErrorOrEventInput);
            const adaptedError = this._adaptError(rawErrorOrEventInput);
            const { error, message } = adaptedError;
            // Close with abnormal closure code so _handleClose will reconnect if there's a socket
            this._disconnect(ABNORMAL_CLOSURE_CODE, message);
            this._debug("Processed error. Dispatching Event:", message, error);
            if (this.onerror) this.onerror(adaptedError);
            this._debug("exec error listeners");
            this._listeners.error.forEach((listener)=>this._callEventListener(adaptedError, listener));
            // If we never even got a ws instance, _disconnect returned early so we need to explicitly retry here
            if (!this._ws && this._shouldReconnect) {
                this._debug("Error before socket created; scheduling initial reconnect.");
                this._connect();
            }
        };
        /**
         * Handles WebSocket close events, either native or synthesized internally.
         *
         * Adapts the event if necessary, manages state, dispatches standardized close events,
         * and initiates reconnection if appropriate.
         *
         * @param eventInfo - Either an internal Events.CloseEvent or a native DOM CloseEvent.
         */ this._handleClose = (event)=>{
            this._debug("Raw close event received by _handleClose:", event);
            // Adapt event if event is an instance of the (browser) native CloseEvent
            const isNativeCloseEvent = typeof CloseEvent !== "undefined" && event instanceof CloseEvent;
            const adaptedEvent = isNativeCloseEvent ? new Events.CloseEvent(event.code, event.reason, this) : event;
            // Clean up state
            this._clearTimeouts();
            this._ws = undefined;
            this._connectLock = false;
            // Determine reconnection intent
            if (this._closeCalled) {
                this._shouldReconnect = false;
                this._debug("Reconnection stopped: RWS.close() was called.");
            } else if (adaptedEvent.code === 1000) {
                this._shouldReconnect = false;
                this._debug("Reconnection stopped: Received close code 1000 (intentional server close).");
            }
            adaptedEvent.willReconnect = this._shouldReconnect;
            // Dispatch event to listeners
            if (this.onclose) this.onclose(adaptedEvent);
            this._listeners.close.forEach((listener)=>this._callEventListener(adaptedEvent, listener));
            // Conditionally attempt reconnection
            if (this._shouldReconnect) this._connect();
        };
        this._url = url;
        this._protocols = protocols;
        this._options = options;
        this._WebSocket = this._options.WebSocket || getGlobalWebSocket();
        if (!isWebSocket(this._WebSocket)) {
            throw Error("No valid WebSocket class provided");
        }
        if (this._options.startClosed) {
            this._shouldReconnect = false;
        }
        this._connect();
    }
    static get CONNECTING() {
        return 0;
    }
    static get OPEN() {
        return 1;
    }
    static get CLOSING() {
        return 2;
    }
    static get CLOSED() {
        return 3;
    }
    get CONNECTING() {
        return ReconnectingWebSocket.CONNECTING;
    }
    get OPEN() {
        return ReconnectingWebSocket.OPEN;
    }
    get CLOSING() {
        return ReconnectingWebSocket.CLOSING;
    }
    get CLOSED() {
        return ReconnectingWebSocket.CLOSED;
    }
    get binaryType() {
        return this._ws ? this._ws.binaryType : this._binaryType;
    }
    set binaryType(value) {
        this._binaryType = value;
        if (this._ws) {
            this._ws.binaryType = value;
        }
    }
    /**
     * Returns the number or connection retries
     */ get retryCount() {
        return Math.max(this._retryCount, 0);
    }
    /**
     * The number of bytes of data that have been queued using calls to send() but not yet
     * transmitted to the network. This value resets to zero once all queued data has been sent.
     * This value does not reset to zero when the connection is closed; if you keep calling send(),
     * this will continue to climb. Read only
     */ get bufferedAmount() {
        const bytes = this._messageQueue.reduce((acc, message)=>{
            if (typeof message === "string") {
                acc += message.length; // not byte size
            } else if (message instanceof Blob) {
                acc += message.size;
            } else {
                acc += message.byteLength;
            }
            return acc;
        }, 0);
        return bytes + (this._ws ? this._ws.bufferedAmount : 0);
    }
    /**
     * The extensions selected by the server. This is currently only the empty string or a list of
     * extensions as negotiated by the connection
     */ get extensions() {
        return this._ws ? this._ws.extensions : "";
    }
    /**
     * A string indicating the name of the sub-protocol the server selected;
     * this will be one of the strings specified in the protocols parameter when creating the
     * WebSocket object
     */ get protocol() {
        return this._ws ? this._ws.protocol : "";
    }
    /**
     * The current state of the connection; this is one of the Ready state constants
     */ get readyState() {
        if (this._ws) {
            return this._ws.readyState;
        }
        return this._options.startClosed ? ReconnectingWebSocket.CLOSED : ReconnectingWebSocket.CONNECTING;
    }
    /**
     * The URL as resolved by the constructor
     */ get url() {
        return this._ws ? this._ws.url : "";
    }
    /**
     * Closes the WebSocket connection or connection attempt, if any. If the connection is already
     * CLOSED, this method does nothing
     */ close(code = 1000, reason) {
        this._closeCalled = true;
        this._shouldReconnect = false;
        this._clearTimeouts();
        if (!this._ws) {
            this._debug("close enqueued: no ws instance");
            return;
        }
        if (this._ws.readyState === this.CLOSED) {
            this._debug("close: already closed");
            return;
        }
        this._ws.close(code, reason);
    }
    /**
     * Closes the WebSocket connection or connection attempt and connects again.
     * Resets retry counter;
     */ reconnect(code, reason) {
        this._shouldReconnect = true;
        this._closeCalled = false;
        this._retryCount = -1;
        if (!this._ws || this._ws.readyState === this.CLOSED) {
            this._connect();
        } else {
            // If the socket is already connected then disconnect. The socket will conditionally reconnected in _handleClose
            this._disconnect(code, reason);
        }
    }
    /**
     * Enqueue specified data to be transmitted to the server over the WebSocket connection
     */ send(data) {
        if (this._ws && this._ws.readyState === this.OPEN) {
            this._debug("send", data);
            this._ws.send(data);
        } else {
            const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
            if (this._messageQueue.length < maxEnqueuedMessages) {
                this._debug("enqueue", data);
                this._messageQueue.push(data);
            }
        }
    }
    /**
     * Register an event handler of a specific event type
     */ addEventListener(type, listener) {
        if (this._listeners[type]) {
            // @ts-ignore
            this._listeners[type].push(listener);
        }
    }
    dispatchEvent(event) {
        const listeners = this._listeners[event.type];
        if (listeners) {
            for (const listener of listeners){
                this._callEventListener(event, listener);
            }
        }
        return true;
    }
    /**
     * Removes an event listener
     */ removeEventListener(type, listener) {
        if (this._listeners[type]) {
            // @ts-ignore
            this._listeners[type] = this._listeners[type].filter(// @ts-ignore
            (l)=>l !== listener);
        }
    }
    _debug(...args) {
        if (this._options.debug) {
            // not using spread because compiled version uses Symbols
            // tslint:disable-next-line
            console.log.apply(console, [
                "RWS>",
                ...args
            ]);
        }
    }
    _getNextDelay() {
        const { reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor, minReconnectionDelay = DEFAULT.minReconnectionDelay, maxReconnectionDelay = DEFAULT.maxReconnectionDelay } = this._options;
        let delay = 0;
        if (this._retryCount > 0) {
            delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
            if (delay > maxReconnectionDelay) {
                delay = maxReconnectionDelay;
            }
        }
        this._debug("next delay", delay);
        return delay;
    }
    _wait() {
        return new Promise((resolve)=>{
            setTimeout(resolve, this._getNextDelay());
        });
    }
    _getNextUrl(urlProvider) {
        if (typeof urlProvider === "string") {
            return Promise.resolve(urlProvider);
        }
        if (typeof urlProvider === "function") {
            const url = urlProvider();
            if (typeof url === "string") {
                return Promise.resolve(url);
            }
            // @ts-ignore redundant check
            if (url.then) {
                return url;
            }
        }
        throw Error("Invalid URL");
    }
    /**
     * Handles the final "tear down" process when connection attempts must permanently stop
     * (e.g., max retries reached, fatal configuration error).
     * Releases locks, disables reconnection, dispatches final error and close events.
     *
     * @param error - The specific Error instance indicating the reason for termination.
     * @param closeReason - The reason string to use for the final CloseEvent.
     */ _shutdown(error, closeReason) {
        this._debug("Terminating connection attempts. Reason:", error.message);
        // Ensure state prevents further attempts
        this._connectLock = false;
        this._shouldReconnect = false;
        // Dispatch error event
        const errorEvent = this._adaptError(error);
        if (this.onerror) this.onerror(errorEvent);
        this._listeners.error.forEach((listener)=>this._callEventListener(errorEvent, listener));
        // Dispatch close event
        const closeEvent = new Events.CloseEvent(1000, closeReason, this);
        closeEvent.willReconnect = false;
        if (this.onclose) this.onclose(closeEvent);
        this._listeners.close.forEach((listener)=>this._callEventListener(closeEvent, listener));
    }
    _connect() {
        // Check locks and intent
        if (this._connectLock) {
            this._debug("Connection attempt already in progress.");
            return;
        }
        if (!this._shouldReconnect) {
            this._debug("Reconnection disabled, skipping connect attempt.");
            return;
        }
        // Set lock for this attempt
        this._connectLock = true;
        const { maxRetries = DEFAULT.maxRetries, connectionTimeout = DEFAULT.connectionTimeout } = this._options;
        // Max retries check
        if (this._retryCount >= maxRetries) {
            this._shutdown(new Error(`Max retries (${maxRetries}) reached. Giving up.`), "Max retries reached");
            return;
        }
        // Prepare connection attempt
        this._retryCount++;
        this._debug("connect", this._retryCount);
        this._removeListeners();
        // Connection attempt
        this._wait().then(()=>this._getNextUrl(this._url)).then((url)=>{
            // Close could be called before creating the ws
            if (this._closeCalled) {
                this._connectLock = false;
                this._debug("Connection cancelled: ReconnectingWebSocket.close() called during setup.");
                return;
            }
            this._debug("connect", {
                url,
                protocols: this._protocols
            });
            this._ws = this._protocols ? new this._WebSocket(url, this._protocols) : new this._WebSocket(url);
            this._ws.binaryType = this._binaryType;
            this._addListeners();
            this._connectLock = false;
            this._connectTimeout = setTimeout(()=>this._handleTimeout(), connectionTimeout);
        }).catch((error)=>{
            this._debug("Connection setup failed:", error);
            this._connectLock = false;
            this._handleError(error);
        });
    }
    _handleTimeout() {
        this._debug("timeout event");
        this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
    }
    _disconnect(code = 1000, reason) {
        this._clearTimeouts();
        if (!this._ws) {
            return;
        }
        this._removeListeners();
        try {
            this._ws.close(code, reason);
            this._handleClose(new Events.CloseEvent(code, reason, this));
        } catch (error) {
        // ignore
        }
    }
    _acceptOpen() {
        this._debug("accept open");
        this._retryCount = 0;
    }
    _callEventListener(event, listener) {
        if ("handleEvent" in listener) {
            // @ts-ignore
            listener.handleEvent(event);
        } else {
            // @ts-ignore
            listener(event);
        }
    }
    /**
     * Adapts a raw error or event input into a standardized `Events.ErrorEvent`.
     * This utility is called by `_handleError` to ensure it operates on a
     * consistent error structure.
     * @param rawErrorOrEventInput - The raw error data (e.g., Error instance, DOM Event, Events.ErrorEvent).
     * @returns A standardized `Events.ErrorEvent` containing an underlying `Error` instance.
     */ _adaptError(rawErrorOrEventInput) {
        this._debug("Adapting raw error/event via _adaptError:", rawErrorOrEventInput);
        let underlyingError;
        if (rawErrorOrEventInput instanceof Events.ErrorEvent && rawErrorOrEventInput.error instanceof Error) {
            return rawErrorOrEventInput;
        }
        if (rawErrorOrEventInput instanceof Error) {
            underlyingError = rawErrorOrEventInput;
        } else if (typeof Event !== "undefined" && rawErrorOrEventInput instanceof Event && rawErrorOrEventInput.type === "error") {
            underlyingError = new Error("WebSocket low-level error occurred (see browser/runtime console for native event details).");
        } else {
            underlyingError = new Error(`Unknown WebSocket error. Raw data: ${String(rawErrorOrEventInput !== null && rawErrorOrEventInput !== void 0 ? rawErrorOrEventInput : "undefined")}`);
        }
        return new Events.ErrorEvent(underlyingError, this);
    }
    _removeListeners() {
        if (!this._ws) {
            return;
        }
        this._debug("removeListeners");
        this._ws.removeEventListener("open", this._handleOpen);
        this._ws.removeEventListener("close", this._handleClose);
        this._ws.removeEventListener("message", this._handleMessage);
        // @ts-ignore
        this._ws.removeEventListener("error", this._handleError);
    }
    _addListeners() {
        if (!this._ws) {
            return;
        }
        this._debug("addListeners");
        this._ws.addEventListener("open", this._handleOpen);
        this._ws.addEventListener("close", this._handleClose);
        this._ws.addEventListener("message", this._handleMessage);
        this._ws.addEventListener("error", this._handleError);
    }
    _clearTimeouts() {
        clearTimeout(this._connectTimeout);
        clearTimeout(this._uptimeTimeout);
    }
}
exports.ReconnectingWebSocket = ReconnectingWebSocket;
}}),
"[project]/node_modules/hume/core/websocket/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */ __exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/websocket/ws.js [app-rsc] (ecmascript)"), exports);
}}),
"[project]/node_modules/hume/core/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serialization = void 0;
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */ __exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/fetcher/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/runtime/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/stream/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/utils/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/pagination/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/form-data-utils/index.js [app-rsc] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/file.js [app-rsc] (ecmascript)"), exports);
exports.serialization = __importStar(__turbopack_context__.r("[project]/node_modules/hume/core/schemas/index.js [app-rsc] (ecmascript)"));
// This one is manually added
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/core/websocket/index.js [app-rsc] (ecmascript)"), exports);
}}),
"[project]/node_modules/hume/core/headers.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mergeHeaders = mergeHeaders;
exports.mergeOnlyDefinedHeaders = mergeOnlyDefinedHeaders;
function mergeHeaders(...headersArray) {
    const result = {};
    for (const [key, value] of headersArray.filter((headers)=>headers != null).flatMap((headers)=>Object.entries(headers))){
        if (value != null) {
            result[key] = value;
        } else if (key in result) {
            delete result[key];
        }
    }
    return result;
}
function mergeOnlyDefinedHeaders(...headersArray) {
    const result = {};
    for (const [key, value] of headersArray.filter((headers)=>headers != null).flatMap((headers)=>Object.entries(headers))){
        if (value != null) {
            result[key] = value;
        }
    }
    return result;
}
}}),

};

//# sourceMappingURL=node_modules_hume_core_a02325eb._.js.map