module.exports = {

"[project]/node_modules/hume/errors/HumeError.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This file was auto-generated by Fern from our API Definition.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeError = void 0;
const json_1 = __turbopack_context__.r("[project]/node_modules/hume/core/json.js [app-rsc] (ecmascript)");
class HumeError extends Error {
    constructor({ message, statusCode, body, rawResponse }){
        super(buildMessage({
            message,
            statusCode,
            body
        }));
        Object.setPrototypeOf(this, HumeError.prototype);
        this.statusCode = statusCode;
        this.body = body;
        this.rawResponse = rawResponse;
    }
}
exports.HumeError = HumeError;
function buildMessage({ message, statusCode, body }) {
    let lines = [];
    if (message != null) {
        lines.push(message);
    }
    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }
    if (body != null) {
        lines.push(`Body: ${(0, json_1.toJson)(body, undefined, 2)}`);
    }
    return lines.join("\n");
}
}}),
"[project]/node_modules/hume/errors/HumeTimeoutError.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This file was auto-generated by Fern from our API Definition.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeTimeoutError = void 0;
class HumeTimeoutError extends Error {
    constructor(message){
        super(message);
        Object.setPrototypeOf(this, HumeTimeoutError.prototype);
    }
}
exports.HumeTimeoutError = HumeTimeoutError;
}}),
"[project]/node_modules/hume/errors/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeTimeoutError = exports.HumeError = void 0;
var HumeError_1 = __turbopack_context__.r("[project]/node_modules/hume/errors/HumeError.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HumeError", {
    enumerable: true,
    get: function() {
        return HumeError_1.HumeError;
    }
});
var HumeTimeoutError_1 = __turbopack_context__.r("[project]/node_modules/hume/errors/HumeTimeoutError.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HumeTimeoutError", {
    enumerable: true,
    get: function() {
        return HumeTimeoutError_1.HumeTimeoutError;
    }
});
}}),
"[project]/node_modules/hume/environments.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/**
 * This file was auto-generated by Fern from our API Definition.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeEnvironment = void 0;
exports.HumeEnvironment = {
    Production: "https://api.hume.ai"
};
}}),
"[project]/node_modules/hume/version.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SDK_VERSION = void 0;
exports.SDK_VERSION = "0.12.2";
}}),
"[project]/node_modules/hume/wrapper/base64Decode.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.base64Decode = base64Decode;
function base64Decode(str) {
    if (typeof Buffer === "function") {
        // Node.js environment
        return Buffer.from(str, "base64");
    } else if (typeof atob === "function") {
        // Browser environment
        return atob(str);
    } else {
        throw new Error("Base64 encoding not supported in this environment.");
    }
}
}}),
"[project]/node_modules/hume/wrapper/base64Encode.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.base64Encode = base64Encode;
function base64Encode(str) {
    if (typeof Buffer === "function") {
        // Node.js environment
        return Buffer.from(str).toString("base64");
    } else if (typeof btoa === "function") {
        // Browser environment
        return btoa(str);
    } else {
        throw new Error("Base64 encoding not supported in this environment.");
    }
}
}}),
"[project]/node_modules/hume/wrapper/convertBase64ToBlob.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertBase64ToBlob = convertBase64ToBlob;
/**
 * Converts a base64-encoded string into a `Blob` object with the specified content type.
 *
 * @param {string} base64 - The base64-encoded string representing binary data.
 * @param {string} contentType - The MIME type to assign to the resulting `Blob`.
 * @returns {Blob} A `Blob` object containing the binary data from the base64 string.
 */ function convertBase64ToBlob(base64, contentType) {
    // Decode base64 string to a binary string
    const binaryString = window.atob(base64);
    // Create a Uint8Array with the same length as the binary string
    const byteArray = new Uint8Array(binaryString.length);
    // Fill the Uint8Array by converting each character's Unicode value to a byte
    for(let i = 0; i < binaryString.length; i++){
        byteArray[i] = binaryString.charCodeAt(i);
    }
    // Create and return a Blob with the specified content type
    return new Blob([
        byteArray
    ], {
        type: contentType
    });
}
}}),
"[project]/node_modules/hume/wrapper/convertBlobToBase64.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertBlobToBase64 = convertBlobToBase64;
/**
 * Converts a `Blob` object into a base64-encoded string.
 * The resulting string contains the binary data from the `Blob`.
 *
 * @param {Blob} blob - The `Blob` object to convert to base64.
 * @returns {Promise<string>} A promise that resolves to a base64-encoded string representing the `Blob` data.
 */ function convertBlobToBase64(blob) {
    return new Promise((resolve, reject)=>{
        const reader = new FileReader();
        // Handle the load event which is triggered when readAsDataURL completes
        reader.onloadend = ()=>{
            // Ensure reader.result is not null and is a string
            if (typeof reader.result === "string") {
                // Extract the Base64 encoded string, skipping the data URL prefix (e.g., "data:image/png;base64,")
                const base64Data = reader.result.split(",")[1];
                if (base64Data) {
                    resolve(base64Data);
                } else {
                    reject(new Error("Failed to split the result into Base64 data."));
                }
            } else {
                reject(new Error("FileReader result is null or not a string."));
            }
        };
        // Handle errors during the read process
        reader.onerror = ()=>{
            var _a;
            reject(new Error(`Error reading blob: ${(_a = reader.error) === null || _a === void 0 ? void 0 : _a.message}`));
        };
        // Initiate reading the blob as a data URL
        reader.readAsDataURL(blob);
    });
}
}}),
"[project]/node_modules/hume/wrapper/ensureSingleValidAudioTrack.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ensureSingleValidAudioTrack = void 0;
/**
 * Ensures that the given media stream contains exactly one valid audio track.
 * Throws an error if no audio tracks are found, if there is more than one audio track,
 * or if the sole audio track is falsy.
 *
 * @param {MediaStream} stream - The media stream object containing audio tracks to validate.
 * @throws {Error} "No audio tracks" if the stream contains zero audio tracks.
 * @throws {Error} "Multiple audio tracks" if the stream contains more than one audio track.
 * @throws {Error} "No audio track" if the sole audio track is falsy.
 */ const ensureSingleValidAudioTrack = (stream)=>{
    const tracks = stream.getAudioTracks();
    if (tracks.length === 0) {
        throw new Error("No audio tracks available");
    } else if (tracks.length > 1) {
        throw new Error("Multiple audio tracks found");
    } else if (!tracks[0]) {
        throw new Error("The audio track is invalid");
    }
};
exports.ensureSingleValidAudioTrack = ensureSingleValidAudioTrack;
}}),
"[project]/node_modules/hume/wrapper/checkForAudioTracks.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkForAudioTracks = void 0;
/**
 * @name checkForAudioTracks
 * @description
 * Check if a MediaStream has audio tracks.
 * @param stream
 * The MediaStream to check
 */ const checkForAudioTracks = (stream)=>{
    const tracks = stream.getAudioTracks();
    if (tracks.length === 0) {
        throw new Error("No audio tracks");
    }
    if (tracks.length > 1) {
        throw new Error("Multiple audio tracks");
    }
    const track = tracks[0];
    if (!track) {
        throw new Error("No audio track");
    }
};
exports.checkForAudioTracks = checkForAudioTracks;
}}),
"[project]/node_modules/hume/wrapper/fetchAccessToken.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fetchAccessToken = void 0;
const base64Encode_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/base64Encode.js [app-rsc] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/zod/index.cjs [app-rsc] (ecmascript)");
/**
 * Fetches a new access token from the Hume API using the provided API key and Secret key.
 *
 * @param args - The arguments for the request.
 * @example
 * ```typescript
 * async function getToken() {
 *   const accessToken = await fetchAccessToken({
 *     apiKey: 'test',
 *     secretKey: 'test',
 *   });
 *
 *   console.log(accessToken); // Outputs the access token
 * }
 * ```
 */ const fetchAccessToken = (_a)=>__awaiter(void 0, [
        _a
    ], void 0, function*({ apiKey, secretKey, host = "api.hume.ai" }) {
        const authString = `${apiKey}:${secretKey}`;
        const encoded = (0, base64Encode_1.base64Encode)(authString);
        const res = yield fetch(`https://${host}/oauth2-cc/token`, {
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                Authorization: `Basic ${encoded}`
            },
            body: new URLSearchParams({
                grant_type: "client_credentials"
            }).toString(),
            cache: "no-cache"
        });
        return zod_1.z.object({
            access_token: zod_1.z.string()
        }).transform((data)=>{
            return data.access_token;
        }).parse((yield res.json()));
    });
exports.fetchAccessToken = fetchAccessToken;
}}),
"[project]/node_modules/hume/wrapper/getAudioStream.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAudioStream = void 0;
/**
 * Requests an audio stream from the user's device using the `getUserMedia` API.
 * The stream will have echo cancellation, noise suppression, and auto gain control enabled.
 *
 * @returns {Promise<MediaStream>} A promise that resolves to a `MediaStream` containing audio data only.
 * @throws {DOMException} If the user denies access or no audio input devices are found.
 */ const getAudioStream = (...args_1)=>__awaiter(void 0, [
        ...args_1
    ], void 0, function*(audioStreamOptions = {}) {
        const { echoCancellation = true, noiseSuppression = true, autoGainControl = true } = audioStreamOptions;
        return navigator.mediaDevices.getUserMedia({
            audio: {
                echoCancellation,
                noiseSuppression,
                autoGainControl
            },
            video: false
        });
    });
exports.getAudioStream = getAudioStream;
}}),
"[project]/node_modules/hume/wrapper/getBrowserSupportedMimeType.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MimeType = void 0;
exports.getBrowserSupportedMimeType = getBrowserSupportedMimeType;
/**
 * Enum representing the supported MIME types for audio recording.
 */ var MimeType;
(function(MimeType) {
    MimeType["WEBM"] = "audio/webm";
    MimeType["MP4"] = "audio/mp4";
    MimeType["WAV"] = "audio/wav";
})(MimeType || (exports.MimeType = MimeType = {}));
/**
 * Checks whether the `MediaRecorder` API is supported in the current environment.
 *
 * @returns {boolean} Returns `true` if the `MediaRecorder` API is supported, otherwise `false`.
 */ function isMediaRecorderSupported() {
    return typeof MediaRecorder !== "undefined";
}
/**
 * Finds and returns the first MIME type from the given array that is supported by the `MediaRecorder`.
 *
 * @param {MimeType[]} mimeTypes - An array of MIME types to check for compatibility.
 * @returns {MimeType | null} The first supported MIME type or `null` if none are supported.
 */ function getSupportedMimeType(mimeTypes) {
    return mimeTypes.find((type)=>MediaRecorder.isTypeSupported(type)) || null;
}
/**
 * Determines if the current browser supports any of the predefined audio MIME types
 * (WEBM, MP4, or WAV) via the `MediaRecorder` API.
 *
 * @returns {MimeTypeResult} An object containing the success status and either a supported MIME type or an error.
 * @throws {Error} If the `MediaRecorder` API is not supported by the browser or no compatible types are found.
 */ function getBrowserSupportedMimeType() {
    // Check if the MediaRecorder API is supported in the current environment.
    if (!isMediaRecorderSupported()) {
        return {
            success: false,
            error: new Error("MediaRecorder is not supported")
        };
    }
    const COMPATIBLE_MIME_TYPES = [
        MimeType.WEBM,
        MimeType.MP4,
        MimeType.WAV
    ];
    // Find the first compatible MIME type that the browser's MediaRecorder supports.
    const supportedMimeType = getSupportedMimeType(COMPATIBLE_MIME_TYPES);
    // If no compatible MIME type is found, return a failure result with an appropriate error message.
    if (!supportedMimeType) {
        return {
            success: false,
            error: new Error("Browser does not support any compatible mime types")
        };
    }
    // If a compatible MIME type is found, return a success result with the supported MIME type.
    return {
        success: true,
        mimeType: supportedMimeType
    };
}
}}),
"[project]/node_modules/hume/wrapper/expressionMeasurement/batch/Job.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Job = void 0;
const errors = __importStar(__turbopack_context__.r("[project]/node_modules/hume/errors/index.js [app-rsc] (ecmascript)"));
class Job {
    constructor(jobId, client){
        this.jobId = jobId;
        this.client = client;
    }
    awaitCompletion() {
        return __awaiter(this, arguments, void 0, function*(timeoutInSeconds = 300) {
            return new Promise((resolve, reject)=>{
                const poller = new JobCompletionPoller(this.jobId, this.client);
                poller.start(resolve);
                setTimeout(()=>{
                    poller.stop();
                    reject(new errors.HumeTimeoutError("Timeout exceeded when polling for job completion"));
                }, timeoutInSeconds * 1000);
            });
        });
    }
}
exports.Job = Job;
class JobCompletionPoller {
    constructor(jobId, client){
        this.jobId = jobId;
        this.client = client;
        this.isPolling = true;
    }
    start(onTerminal) {
        this.isPolling = true;
        this.poll(onTerminal);
    }
    stop() {
        this.isPolling = false;
    }
    poll(onTerminal) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const jobDetails = yield this.client.getJobDetails(this.jobId);
                if (jobDetails.state.status === "COMPLETED" || jobDetails.state.status === "FAILED") {
                    onTerminal();
                    this.stop();
                }
            } catch (_a) {
            // swallow errors while polling
            }
            if (this.isPolling) {
                setTimeout(()=>this.poll(onTerminal), 1000);
            }
        });
    }
}
}}),
"[project]/node_modules/hume/wrapper/expressionMeasurement/batch/BatchClient.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BatchClient = void 0;
const Client_1 = __turbopack_context__.r("[project]/node_modules/hume/api/resources/expressionMeasurement/resources/batch/client/Client.js [app-rsc] (ecmascript)");
const Job_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/expressionMeasurement/batch/Job.js [app-rsc] (ecmascript)");
const core = __importStar(__turbopack_context__.r("[project]/node_modules/hume/core/index.js [app-rsc] (ecmascript)"));
class BatchClient extends Client_1.Batch {
    // This just wraps the return value of the base class's `startInferenceJob` method
    // and returns a `Job` instance (has helper functions to await the job's result) instead of a raw job ID.
    startInferenceJob(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(super.startInferenceJob(request, requestOptions).withRawResponse().then((result)=>{
            return {
                data: new Job_1.Job(result.data.jobId, this),
                rawResponse: result.rawResponse
            };
        }));
    }
}
exports.BatchClient = BatchClient;
}}),
"[project]/node_modules/hume/wrapper/expressionMeasurement/streaming/StreamSocket.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    //TURBOPACK unreachable
    ;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamSocket = void 0;
const ws_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/ws/index.js [app-rsc] (ecmascript)"));
const uuid_1 = __turbopack_context__.r("[project]/node_modules/uuid/dist/esm-node/index.js [app-rsc] (ecmascript)");
const StreamingClient_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/expressionMeasurement/streaming/StreamingClient.js [app-rsc] (ecmascript)");
const base64Encode_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/base64Encode.js [app-rsc] (ecmascript)");
const errors = __importStar(__turbopack_context__.r("[project]/node_modules/hume/errors/index.js [app-rsc] (ecmascript)"));
const serializers = __importStar(__turbopack_context__.r("[project]/node_modules/hume/serialization/index.js [app-rsc] (ecmascript)"));
const fs = __importStar(__turbopack_context__.r("[externals]/fs [external] (fs, cjs)"));
class StreamSocket {
    constructor({ websocket, config, streamWindowMs }){
        this.websocket = websocket;
        this.config = config;
        this.streamWindowMs = streamWindowMs;
    }
    /**
     * Send file on the `StreamSocket`
     *
     * @param file A fs.ReadStream | File | Blob
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */ sendFile(_a) {
        return __awaiter(this, arguments, void 0, function*({ file, config }) {
            var _b, file_1, file_1_1;
            var _c, e_1, _d, _e;
            if (config != null) {
                this.config = config;
            }
            let contents = "";
            if (file instanceof fs.ReadStream) {
                const chunks = [];
                try {
                    for(_b = true, file_1 = __asyncValues(file); file_1_1 = yield file_1.next(), _c = file_1_1.done, !_c; _b = true){
                        _e = file_1_1.value;
                        _b = false;
                        const chunk = _e;
                        chunks.push(Buffer.from(chunk));
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (!_b && !_c && (_d = file_1.return)) yield _d.call(file_1);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                contents = Buffer.concat(chunks).toString("base64");
            } else if (file instanceof Blob) {
                const toBase64 = (file)=>new Promise((res)=>{
                        const reader = new FileReader();
                        reader.readAsDataURL(file);
                        reader.onload = ()=>res(reader.result);
                    });
                contents = yield toBase64(file);
            } else {
                throw new errors.HumeError({
                    message: `file must be one of ReadStream or Blob.`
                });
            }
            const request = {
                payloadId: (0, uuid_1.v4)(),
                data: contents,
                models: this.config,
                rawText: false
            };
            if (this.streamWindowMs != null) {
                request.streamWindowMs = this.streamWindowMs;
            }
            const response = yield this.send(request);
            if (response == null) {
                throw new errors.HumeError({
                    message: `Received no response after sending file: ${file}`
                });
            }
            return response;
        });
    }
    /**
     * Send text on the `StreamSocket`
     *
     * @param text Text to send to the language model.
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */ sendText(_a) {
        return __awaiter(this, arguments, void 0, function*({ text, config }) {
            if (config != null) {
                this.config = config;
            }
            const request = {
                payloadId: (0, uuid_1.v4)(),
                data: text,
                rawText: true,
                models: this.config
            };
            if (this.streamWindowMs != null) {
                request.streamWindowMs = this.streamWindowMs;
            }
            const response = yield this.send(request);
            if (response == null) {
                throw new errors.HumeError({
                    message: `Received no response after sending text: ${text}`
                });
            }
            return response;
        });
    }
    /**
     * Send facemesh landmarks on the `StreamSocket`
     *
     * @param landmarks List of landmark points for multiple faces.
     * The shape of this 3-dimensional list should be (n, 478, 3) where n is the number
     * of faces to be processed, 478 is the number of MediaPipe landmarks per face and 3
     * represents the (x, y, z) coordinates of each landmark.
     * @param config List of model configurations.
     * If set these configurations will overwrite existing configurations
     */ sendFacemesh(_a) {
        return __awaiter(this, arguments, void 0, function*({ landmarks, config }) {
            const response = this.sendText({
                text: (0, base64Encode_1.base64Encode)(JSON.stringify(landmarks)),
                config
            });
            return response;
        });
    }
    /**
     *
     * Reset the streaming sliding window.
     *
     * Call this method when some media has been fully processed and you want to continue using the same
     * streaming connection without leaking context across media samples.
     */ reset() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.send({
                resetStream: true
            });
        });
    }
    /**
     *
     * Get details associated with the current streaming connection.
     *
     */ getJobDetails() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.send({
                jobDetails: true
            });
        });
    }
    /**
     * Closes the underlying socket.
     */ close() {
        this.websocket.close();
    }
    send(payload) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.tillSocketOpen();
            const jsonPayload = serializers.expressionMeasurement.stream.StreamModelsEndpointPayload.jsonOrThrow(payload, {
                unrecognizedObjectKeys: "strip"
            });
            this.websocket.send(JSON.stringify(jsonPayload));
            const response = yield new Promise((resolve)=>{
                this.websocket.addEventListener("message", (event)=>{
                    const response = (0, StreamingClient_1.parse)(event.data);
                    resolve(response);
                });
            });
            if (response != null && isError(response)) {
                throw new errors.HumeError({
                    message: `CODE ${response.code}: ${response.error}`
                });
            }
            return response;
        });
    }
    tillSocketOpen() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.websocket.readyState === ws_1.default.OPEN) {
                return this.websocket;
            }
            return new Promise((resolve, reject)=>{
                this.websocket.addEventListener("open", ()=>{
                    resolve(this.websocket);
                });
                this.websocket.addEventListener("error", (event)=>{
                    reject(event);
                });
            });
        });
    }
}
exports.StreamSocket = StreamSocket;
function isError(response) {
    return response.error != null;
}
}}),
"[project]/node_modules/hume/wrapper/expressionMeasurement/streaming/StreamingClient.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamClient = void 0;
exports.parse = parse;
const serializers = __importStar(__turbopack_context__.r("[project]/node_modules/hume/serialization/index.js [app-rsc] (ecmascript)"));
const StreamSocket_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/expressionMeasurement/streaming/StreamSocket.js [app-rsc] (ecmascript)");
const ws_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/ws/index.js [app-rsc] (ecmascript)"));
class StreamClient {
    constructor(_options){
        this._options = _options;
    }
    connect(args) {
        const websocket = new ws_1.default(`wss://api.hume.ai/v0/stream/models`, {
            headers: {
                "X-Hume-Api-Key": typeof this._options.apiKey === "string" ? this._options.apiKey : ""
            },
            timeout: 10
        });
        websocket.addEventListener("open", (event)=>{
            var _a;
            (_a = args.onOpen) === null || _a === void 0 ? void 0 : _a.call(args, event);
        });
        websocket.addEventListener("error", (e)=>{
            var _a;
            (_a = args.onError) === null || _a === void 0 ? void 0 : _a.call(args, {
                code: e.type,
                error: e.message
            });
        });
        websocket.addEventListener("message", (_a)=>__awaiter(this, [
                _a
            ], void 0, function*({ data }) {
                parse(data, {
                    onMessage: args.onMessage,
                    onError: args.onError
                });
            }));
        websocket.addEventListener("close", (event)=>{
            var _a;
            (_a = args.onClose) === null || _a === void 0 ? void 0 : _a.call(args, event);
        });
        return new StreamSocket_1.StreamSocket({
            websocket,
            streamWindowMs: args.streamWindowMs,
            config: args.config
        });
    }
}
exports.StreamClient = StreamClient;
function parse(data, args = {}) {
    var _a, _b;
    const message = JSON.parse(data);
    const parsedResponse = serializers.expressionMeasurement.stream.Config.parse(message, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: [
            "response"
        ]
    });
    if (parsedResponse.ok) {
        (_a = args.onMessage) === null || _a === void 0 ? void 0 : _a.call(args, parsedResponse.value);
        return parsedResponse.value;
    }
    const parsedError = serializers.expressionMeasurement.stream.StreamErrorMessage.parse(message, {
        unrecognizedObjectKeys: "passthrough",
        allowUnrecognizedUnionMembers: true,
        allowUnrecognizedEnumValues: true,
        breadcrumbsPrefix: [
            "response"
        ]
    });
    if (parsedError.ok) {
        (_b = args.onError) === null || _b === void 0 ? void 0 : _b.call(args, parsedError.value);
        return parsedError.value;
    }
}
}}),
"[project]/node_modules/hume/wrapper/expressionMeasurement/ExpressionMeasurementClient.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExpressionMeasurement = void 0;
const Client_1 = __turbopack_context__.r("[project]/node_modules/hume/api/resources/expressionMeasurement/client/Client.js [app-rsc] (ecmascript)");
const BatchClient_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/expressionMeasurement/batch/BatchClient.js [app-rsc] (ecmascript)");
const StreamingClient_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/expressionMeasurement/streaming/StreamingClient.js [app-rsc] (ecmascript)");
class ExpressionMeasurement extends Client_1.ExpressionMeasurement {
    // BatchClient here is overridden from the generated version, we wrap expression measurement jobs in
    // a helper that makes it easier to await the result of a job.
    get batch() {
        var _a;
        return (_a = this._batch) !== null && _a !== void 0 ? _a : this._batch = new BatchClient_1.BatchClient(this._options);
    }
    get stream() {
        var _a;
        return (_a = this._stream) !== null && _a !== void 0 ? _a : this._stream = new StreamingClient_1.StreamClient(this._options);
    }
}
exports.ExpressionMeasurement = ExpressionMeasurement;
}}),
"[project]/node_modules/hume/wrapper/HumeClient.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeClient = void 0;
const Client_1 = __turbopack_context__.r("[project]/node_modules/hume/Client.js [app-rsc] (ecmascript)");
const ExpressionMeasurementClient_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/expressionMeasurement/ExpressionMeasurementClient.js [app-rsc] (ecmascript)");
class HumeClient extends Client_1.HumeClient {
    constructor(_options){
        super(_options || {});
        this._options = _options;
    }
    get expressionMeasurement() {
        var _a;
        return (_a = this._expressionMeasurement) !== null && _a !== void 0 ? _a : this._expressionMeasurement = new ExpressionMeasurementClient_1.ExpressionMeasurement(this._options);
    }
}
exports.HumeClient = HumeClient;
}}),
"[project]/node_modules/hume/wrapper/EVIWebAudioPlayer.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __awaiter = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _EVIWebAudioPlayer_instances, _a, _EVIWebAudioPlayer_DEFAULT_WORKLET_URL, _EVIWebAudioPlayer_DEFAULT_FFT_SIZE, _EVIWebAudioPlayer_DEFAULT_FFT_INTERVAL, _EVIWebAudioPlayer_BARK_CENTER_FREQUENCIES, _EVIWebAudioPlayer_BYTE_MAX, _EVIWebAudioPlayer_ctx, _EVIWebAudioPlayer_workletNode, _EVIWebAudioPlayer_analyserNode, _EVIWebAudioPlayer_gainNode, _EVIWebAudioPlayer_initialized, _EVIWebAudioPlayer_playing, _EVIWebAudioPlayer_muted, _EVIWebAudioPlayer_volume, _EVIWebAudioPlayer_fft, _EVIWebAudioPlayer_fftTimer, _EVIWebAudioPlayer_fftOptions, _EVIWebAudioPlayer_linearHzToBark, _EVIWebAudioPlayer_startAnalyserPollingIfEnabled, _EVIWebAudioPlayer_emitError;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EVIWebAudioPlayer = void 0;
const convertBase64ToBlob_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/convertBase64ToBlob.js [app-rsc] (ecmascript)");
/**
 * A sequential, glitch-free Web-Audio player for **EVI** audio output.
 *
 * - **Decoding & playback**: base-64 PCM chunks feed an `AudioWorkletNode` and play in order, without gaps.
 * - **One-time init**: await {@link init} in a user-gesture to build audio graph and unlock the browserâ€™s
 *  `AudioContext`; later calls are no-ops.
 * - **Optional FFT**: `{ fft: { enabled: true } }` adds an `AnalyserNode` and emits `'fft'` events; omit to skip.
 * - **Controls**: {@link setVolume}, {@link mute}, {@link unmute}, {@link stop}, {@link dispose}.
 * - **Events**: listen for `'play'`, `'stop'`, `'fft'`, `'error'`.
 */ class EVIWebAudioPlayer extends EventTarget {
    /**Â `true` while any clip is currently audible. */ get playing() {
        return __classPrivateFieldGet(this, _EVIWebAudioPlayer_playing, "f");
    }
    /**Â `true` if gain is set toÂ 0 via {@link mute}. */ get muted() {
        return __classPrivateFieldGet(this, _EVIWebAudioPlayer_muted, "f");
    }
    /** Current output gain (0â€‘1). */ get volume() {
        return __classPrivateFieldGet(this, _EVIWebAudioPlayer_volume, "f");
    }
    /** Most recent FFT frame (empty when analyser disabled). */ get fft() {
        return __classPrivateFieldGet(this, _EVIWebAudioPlayer_fft, "f");
    }
    constructor(opts = {}){
        var _b, _c;
        super();
        _EVIWebAudioPlayer_instances.add(this);
        this.opts = opts;
        _EVIWebAudioPlayer_ctx.set(this, null);
        _EVIWebAudioPlayer_workletNode.set(this, null);
        _EVIWebAudioPlayer_analyserNode.set(this, null);
        _EVIWebAudioPlayer_gainNode.set(this, null);
        _EVIWebAudioPlayer_initialized.set(this, false);
        _EVIWebAudioPlayer_playing.set(this, false);
        _EVIWebAudioPlayer_muted.set(this, false);
        _EVIWebAudioPlayer_volume.set(this, void 0);
        _EVIWebAudioPlayer_fft.set(this, _a.emptyFft());
        _EVIWebAudioPlayer_fftTimer.set(this, null);
        _EVIWebAudioPlayer_fftOptions.set(this, null);
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_volume, (_b = opts.volume) !== null && _b !== void 0 ? _b : 1.0, "f");
        // Resolve FFT options if enabled
        if ((_c = opts.fft) === null || _c === void 0 ? void 0 : _c.enabled) {
            const { size, interval, transform } = opts.fft;
            __classPrivateFieldSet(this, _EVIWebAudioPlayer_fftOptions, {
                size: size !== null && size !== void 0 ? size : __classPrivateFieldGet(_a, _a, "f", _EVIWebAudioPlayer_DEFAULT_FFT_SIZE),
                interval: interval !== null && interval !== void 0 ? interval : __classPrivateFieldGet(_a, _a, "f", _EVIWebAudioPlayer_DEFAULT_FFT_INTERVAL),
                transform: transform !== null && transform !== void 0 ? transform : __classPrivateFieldGet(_a, _a, "m", _EVIWebAudioPlayer_linearHzToBark)
            }, "f");
        }
    }
    /**
     * Generate an empty FFT frame array.
     * Useful as an initial or placeholder FFT dataset before any real analysis.
     *
     * @returns A number[] filled with zeros, length equal to the Bark band count (24).
     */ static emptyFft() {
        return Array(__classPrivateFieldGet(_a, _a, "f", _EVIWebAudioPlayer_BARK_CENTER_FREQUENCIES).length).fill(0);
    }
    /**
     * * Subscribes to a player event and returns `this` for chaining.
     *
     * @param type One of `'play'`, `'stop'`, `'fft'`, or `'error'`.
     * @param fn Handler invoked with the eventâ€™s typed `detail` payload.
     * @param opts Optional `AddEventListenerOptions` (e.g. `{ once: true }`).
     *
     * @example
     *  ```ts
     *  const player = new EVIWebAudioPlayer();
     *  player
     *    .on('play', e => console.log('play',  e.detail.id))
     *    .on('stop', e => console.log('stop',  e.detail.id))
     *    .on('fft', e => console.log('stop',  e.detail.fft))
     *    .on('error', e => console.error('error', e.detail.message));
     *  ```
     */ on(type, fn, opts) {
        super.addEventListener(type, fn, opts);
        return this;
    }
    /**
     * Set up and start the playerâ€™s Web-Audio pipeline.
     *
     * - Creates a **suspended** `AudioContext`, loads the worklet processor, wires `AudioWorkletNode â†’ (AnalyserNode?) â†’ GainNode â†’ destination`, then calls `resume()`.
     * - Must be awaited inside a user-gesture (click/tap/key); later calls are no-ops.
     * - If `fft.enabled` is `false` (or `fft` is omitted), no `AnalyserNode` or polling timer is created.
     *
     * **Safari quirk:** Safari locks an `AudioContext` to the deviceâ€™s current sample rate at creation.
     * If you open a Bluetooth headset mic afterward, the OS may switch to the 16 kHz HFP profile and down-sample playback, which sounds â€œtelephone-y.â€
     * To avoid this, call `getUserMedia()` (or otherwise open audio input) **before** `init()`.
     *
     * @throws {Error} If the browser lacks `AudioWorklet` support, or if `AudioContext.resume()` is rejected (autoplay policy, device error).
     */ init() {
        return __awaiter(this, void 0, void 0, function*() {
            if (__classPrivateFieldGet(this, _EVIWebAudioPlayer_initialized, "f")) return;
            // Create the AudioContext
            __classPrivateFieldSet(this, _EVIWebAudioPlayer_ctx, new AudioContext(), "f");
            // Fail fast if AudioWorklet isnâ€™t supported
            if (!__classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").audioWorklet) {
                const msg = "AudioWorklet is not supported in this browser";
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_instances, "m", _EVIWebAudioPlayer_emitError).call(this, msg);
                throw new Error(msg);
            }
            try {
                // Build GainNode
                __classPrivateFieldSet(this, _EVIWebAudioPlayer_gainNode, __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").createGain(), "f");
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f").gain.value = __classPrivateFieldGet(this, _EVIWebAudioPlayer_volume, "f");
                // Build AnalyserNode (optional)
                if (__classPrivateFieldGet(this, _EVIWebAudioPlayer_fftOptions, "f")) {
                    __classPrivateFieldSet(this, _EVIWebAudioPlayer_analyserNode, __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").createAnalyser(), "f");
                    __classPrivateFieldGet(this, _EVIWebAudioPlayer_analyserNode, "f").fftSize = __classPrivateFieldGet(this, _EVIWebAudioPlayer_fftOptions, "f").size;
                }
                // Loads the AudioWorklet processor module.
                yield __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").audioWorklet.addModule(__classPrivateFieldGet(_a, _a, "f", _EVIWebAudioPlayer_DEFAULT_WORKLET_URL));
                // Build AudioWorkletNode
                __classPrivateFieldSet(this, _EVIWebAudioPlayer_workletNode, new AudioWorkletNode(__classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f"), "audio-processor"), "f");
                // When the worklet posts { type: "ended" }, mark playback stopped and emit a `'stop'` event.
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f").port.onmessage = (e)=>{
                    if (e.data.type === "ended") {
                        __classPrivateFieldSet(this, _EVIWebAudioPlayer_playing, false, "f");
                        this.dispatchEvent(new CustomEvent("stop", {
                            detail: {
                                id: "stream"
                            }
                        }));
                    }
                };
                // Audio graph nodes
                const workletNode = __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f"); // AudioWorkletNode (PCM processor)
                const analyserNode = __classPrivateFieldGet(this, _EVIWebAudioPlayer_analyserNode, "f"); // Optional AnalyserNode (FFT)
                const gainNode = __classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f"); // GainNode (volume control)
                const destination = __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").destination; // AudioDestinationNode (speakers)
                // Analyser node is filtered out of audio graph if null (FFT disabled)
                const audioGraph = [
                    workletNode,
                    analyserNode,
                    gainNode,
                    destination
                ].filter(Boolean);
                // Wire nodes: AudioWorkletNode â†’ (AnalyserNode?) â†’ GainNode â†’ AudioDestinationNode
                audioGraph.reduce((prev, next)=>(prev.connect(next), next));
                // If an analyser is configured, begin polling it at the resolved interval and dispatching `'fft'` events for each frame.
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_instances, "m", _EVIWebAudioPlayer_startAnalyserPollingIfEnabled).call(this);
                // Resume the AudioContext now that the audio graph is fully wired.
                // Browsers allow `resume()` only inside a user-gesture callback.
                // Any rejection (autoplay policy, hardware issue, etc.) is caught by the outer catch-block below, which emits an 'error' event and re-throws.
                yield __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").resume();
                __classPrivateFieldSet(this, _EVIWebAudioPlayer_initialized, true, "f");
            } catch (err) {
                const suffix = err instanceof Error ? `: ${err.message}` : String(err);
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_instances, "m", _EVIWebAudioPlayer_emitError).call(this, `Failed to initialize audio player${suffix}`);
                throw err;
            }
        });
    }
    /**
     * Queue one {@link AudioOutput} message for playback.
     *
     * Decodes the base-64 PCM data, sends it to the `AudioWorkletNode` for glitch-free, in-order playback, and emits `'play'` for the first chunk of a new stream.
     *
     * @param message The `AudioOutput` message received from EVIâ€™s WebSocket.
     *
     * @see {@link https://dev.hume.ai/reference/empathic-voice-interface-evi/chat/chat#receive.Audio-Output.type API Reference}
     */ enqueue(message) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!__classPrivateFieldGet(this, _EVIWebAudioPlayer_initialized, "f") || !__classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f")) {
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_instances, "m", _EVIWebAudioPlayer_emitError).call(this, "Audio player is not initialized");
                return;
            }
            try {
                const { data, id } = message;
                const blob = (0, convertBase64ToBlob_1.convertBase64ToBlob)(data);
                const buffer = yield blob.arrayBuffer();
                const audio = yield __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").decodeAudioData(buffer);
                const pcmData = audio.getChannelData(0);
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f").port.postMessage({
                    type: "audio",
                    data: pcmData
                });
                __classPrivateFieldSet(this, _EVIWebAudioPlayer_playing, true, "f");
                this.dispatchEvent(new CustomEvent("play", {
                    detail: {
                        id
                    }
                }));
            } catch (err) {
                const msg = err instanceof Error ? err.message : "Unknown error";
                __classPrivateFieldGet(this, _EVIWebAudioPlayer_instances, "m", _EVIWebAudioPlayer_emitError).call(this, `Failed to queue clip: ${msg}`);
            }
        });
    }
    /**
     * Flush the worklet queue and output silence.
     */ stop() {
        var _b;
        // Clear buffered audio from the worklet queue
        (_b = __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f")) === null || _b === void 0 ? void 0 : _b.port.postMessage({
            type: "fadeAndClear"
        });
        // Restart analyser polling so fft events continue after stopping or clearing the queue
        __classPrivateFieldGet(this, _EVIWebAudioPlayer_instances, "m", _EVIWebAudioPlayer_startAnalyserPollingIfEnabled).call(this);
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_playing, false, "f");
        this.dispatchEvent(new CustomEvent("stop", {
            detail: {
                id: "manual"
            }
        }));
    }
    /**
     * Set the master gain ({@link volume}) to a value between `0` (_silent_) and `1` (_full volume_).
     *
     * - Clamps out-of-range values.
     * - If called before {@link init}, stores volume for when `AudioContext` is created.
     * - If currently {@link muted}, updates stored volume but keeps output silent until {@link unmute}.
     *
     * @param volume Desired gain; clamped to [0, 1].
     */ setVolume(volume) {
        const clampedVolume = Math.max(0, Math.min(volume, 1));
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_volume, clampedVolume, "f");
        if (__classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f") && __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f") && !__classPrivateFieldGet(this, _EVIWebAudioPlayer_muted, "f")) {
            __classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f").gain.setValueAtTime(clampedVolume, __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").currentTime);
        }
    }
    /**
     * Mute output instantly by setting the gain to 0. Retains the last volume internally for later restore.
     */ mute() {
        if (!__classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f") || !__classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f")) return;
        __classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f").gain.setValueAtTime(0, __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").currentTime);
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_muted, true, "f");
    }
    /**
     * Restore output gain to the last set volume (via setVolume).
     */ unmute() {
        if (!__classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f") || !__classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f")) return;
        __classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f").gain.setValueAtTime(__classPrivateFieldGet(this, _EVIWebAudioPlayer_volume, "f"), __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").currentTime);
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_muted, false, "f");
    }
    /**
     * Tear down all Web-Audio resources (worklet, analyser, gain, context) and reset state so {@link init} can be called again.
     */ dispose() {
        var _b, _c, _d, _e, _f, _g, _h;
        if (__classPrivateFieldGet(this, _EVIWebAudioPlayer_fftTimer, "f") != null) {
            clearInterval(__classPrivateFieldGet(this, _EVIWebAudioPlayer_fftTimer, "f"));
            __classPrivateFieldSet(this, _EVIWebAudioPlayer_fftTimer, null, "f");
        }
        (_b = __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f")) === null || _b === void 0 ? void 0 : _b.port.postMessage({
            type: "fadeAndClear"
        });
        (_c = __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f")) === null || _c === void 0 ? void 0 : _c.port.postMessage({
            type: "end"
        });
        (_d = __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f")) === null || _d === void 0 ? void 0 : _d.port.close();
        (_e = __classPrivateFieldGet(this, _EVIWebAudioPlayer_workletNode, "f")) === null || _e === void 0 ? void 0 : _e.disconnect();
        (_f = __classPrivateFieldGet(this, _EVIWebAudioPlayer_analyserNode, "f")) === null || _f === void 0 ? void 0 : _f.disconnect();
        (_g = __classPrivateFieldGet(this, _EVIWebAudioPlayer_gainNode, "f")) === null || _g === void 0 ? void 0 : _g.disconnect();
        (_h = __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f")) === null || _h === void 0 ? void 0 : _h.close().catch(()=>void 0);
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_initialized, false, "f");
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_playing, false, "f");
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_fft, _a.emptyFft(), "f");
    }
}
exports.EVIWebAudioPlayer = EVIWebAudioPlayer;
_a = EVIWebAudioPlayer, _EVIWebAudioPlayer_ctx = new WeakMap(), _EVIWebAudioPlayer_workletNode = new WeakMap(), _EVIWebAudioPlayer_analyserNode = new WeakMap(), _EVIWebAudioPlayer_gainNode = new WeakMap(), _EVIWebAudioPlayer_initialized = new WeakMap(), _EVIWebAudioPlayer_playing = new WeakMap(), _EVIWebAudioPlayer_muted = new WeakMap(), _EVIWebAudioPlayer_volume = new WeakMap(), _EVIWebAudioPlayer_fft = new WeakMap(), _EVIWebAudioPlayer_fftTimer = new WeakMap(), _EVIWebAudioPlayer_fftOptions = new WeakMap(), _EVIWebAudioPlayer_instances = new WeakSet(), _EVIWebAudioPlayer_linearHzToBark = function _EVIWebAudioPlayer_linearHzToBark(linearData, sampleRate) {
    const maxFrequency = sampleRate / 2;
    const frequencyResolution = maxFrequency / linearData.length;
    return __classPrivateFieldGet(_a, _a, "f", _EVIWebAudioPlayer_BARK_CENTER_FREQUENCIES).map((barkFreq)=>{
        var _b;
        const linearDataIndex = Math.round(barkFreq / frequencyResolution);
        const magnitude = (_b = linearData[linearDataIndex]) !== null && _b !== void 0 ? _b : 0;
        return magnitude / __classPrivateFieldGet(_a, _a, "f", _EVIWebAudioPlayer_BYTE_MAX) * 2;
    });
}, _EVIWebAudioPlayer_startAnalyserPollingIfEnabled = function _EVIWebAudioPlayer_startAnalyserPollingIfEnabled() {
    if (!__classPrivateFieldGet(this, _EVIWebAudioPlayer_fftOptions, "f") || !__classPrivateFieldGet(this, _EVIWebAudioPlayer_analyserNode, "f")) return;
    if (__classPrivateFieldGet(this, _EVIWebAudioPlayer_fftTimer, "f")) clearInterval(__classPrivateFieldGet(this, _EVIWebAudioPlayer_fftTimer, "f"));
    const { interval, transform } = __classPrivateFieldGet(this, _EVIWebAudioPlayer_fftOptions, "f");
    __classPrivateFieldSet(this, _EVIWebAudioPlayer_fftTimer, window.setInterval(()=>{
        const bins = new Uint8Array(__classPrivateFieldGet(this, _EVIWebAudioPlayer_analyserNode, "f").frequencyBinCount);
        __classPrivateFieldGet(this, _EVIWebAudioPlayer_analyserNode, "f").getByteFrequencyData(bins);
        __classPrivateFieldSet(this, _EVIWebAudioPlayer_fft, transform(bins, __classPrivateFieldGet(this, _EVIWebAudioPlayer_ctx, "f").sampleRate), "f");
        this.dispatchEvent(new CustomEvent("fft", {
            detail: {
                fft: __classPrivateFieldGet(this, _EVIWebAudioPlayer_fft, "f")
            }
        }));
    }, interval), "f");
}, _EVIWebAudioPlayer_emitError = function _EVIWebAudioPlayer_emitError(message) {
    this.dispatchEvent(new CustomEvent("error", {
        detail: {
            message
        }
    }));
};
/** Default URL of the `audio-worklet.js` processor module, fetched from Hume AIâ€™s CDN. */ _EVIWebAudioPlayer_DEFAULT_WORKLET_URL = {
    value: "https://storage.googleapis.com/evi-react-sdk-assets/audio-worklet-20250506.js"
};
/** Default FFT size (power-of-two). */ _EVIWebAudioPlayer_DEFAULT_FFT_SIZE = {
    value: 2048
};
/** Default analyser poll interval (16 ms). */ _EVIWebAudioPlayer_DEFAULT_FFT_INTERVAL = {
    value: 16
};
/** Barkâ€‘scale center frequencies (hz) used by the default transform. https://en.wikipedia.org/wiki/Bark_scale */ _EVIWebAudioPlayer_BARK_CENTER_FREQUENCIES = {
    value: [
        50,
        150,
        250,
        350,
        450,
        570,
        700,
        840,
        1000,
        1170,
        1370,
        1600,
        1850,
        2150,
        2500,
        2900,
        3400,
        4000,
        4800,
        5800,
        7000,
        8500,
        10500,
        13500
    ]
};
/** Max byte magnitude (255) returned by `AnalyserNode.getByteFrequencyData`. */ _EVIWebAudioPlayer_BYTE_MAX = {
    value: 255
};
}}),
"[project]/node_modules/hume/wrapper/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EVIWebAudioPlayer = exports.HumeClient = exports.getBrowserSupportedMimeType = exports.MimeType = exports.getAudioStream = exports.fetchAccessToken = exports.checkForAudioTracks = exports.ensureSingleValidAudioTrack = exports.convertBlobToBase64 = exports.convertBase64ToBlob = exports.base64Encode = exports.base64Decode = void 0;
var base64Decode_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/base64Decode.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "base64Decode", {
    enumerable: true,
    get: function() {
        return base64Decode_1.base64Decode;
    }
});
var base64Encode_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/base64Encode.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "base64Encode", {
    enumerable: true,
    get: function() {
        return base64Encode_1.base64Encode;
    }
});
var convertBase64ToBlob_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/convertBase64ToBlob.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "convertBase64ToBlob", {
    enumerable: true,
    get: function() {
        return convertBase64ToBlob_1.convertBase64ToBlob;
    }
});
var convertBlobToBase64_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/convertBlobToBase64.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "convertBlobToBase64", {
    enumerable: true,
    get: function() {
        return convertBlobToBase64_1.convertBlobToBase64;
    }
});
var ensureSingleValidAudioTrack_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/ensureSingleValidAudioTrack.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "ensureSingleValidAudioTrack", {
    enumerable: true,
    get: function() {
        return ensureSingleValidAudioTrack_1.ensureSingleValidAudioTrack;
    }
});
var checkForAudioTracks_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/checkForAudioTracks.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "checkForAudioTracks", {
    enumerable: true,
    get: function() {
        return checkForAudioTracks_1.checkForAudioTracks;
    }
});
var fetchAccessToken_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/fetchAccessToken.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "fetchAccessToken", {
    enumerable: true,
    get: function() {
        return fetchAccessToken_1.fetchAccessToken;
    }
});
var getAudioStream_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/getAudioStream.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "getAudioStream", {
    enumerable: true,
    get: function() {
        return getAudioStream_1.getAudioStream;
    }
});
var getBrowserSupportedMimeType_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/getBrowserSupportedMimeType.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "MimeType", {
    enumerable: true,
    get: function() {
        return getBrowserSupportedMimeType_1.MimeType;
    }
});
Object.defineProperty(exports, "getBrowserSupportedMimeType", {
    enumerable: true,
    get: function() {
        return getBrowserSupportedMimeType_1.getBrowserSupportedMimeType;
    }
});
var HumeClient_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/HumeClient.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HumeClient", {
    enumerable: true,
    get: function() {
        return HumeClient_1.HumeClient;
    }
});
var EVIWebAudioPlayer_1 = __turbopack_context__.r("[project]/node_modules/hume/wrapper/EVIWebAudioPlayer.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "EVIWebAudioPlayer", {
    enumerable: true,
    get: function() {
        return EVIWebAudioPlayer_1.EVIWebAudioPlayer;
    }
});
}}),
"[project]/node_modules/hume/Client.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */ var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeClient = void 0;
const core = __importStar(__turbopack_context__.r("[project]/node_modules/hume/core/index.js [app-rsc] (ecmascript)"));
const Client_1 = __turbopack_context__.r("[project]/node_modules/hume/api/resources/tts/client/Client.js [app-rsc] (ecmascript)");
const Client_2 = __turbopack_context__.r("[project]/node_modules/hume/api/resources/empathicVoice/client/Client.js [app-rsc] (ecmascript)");
const Client_3 = __turbopack_context__.r("[project]/node_modules/hume/api/resources/expressionMeasurement/client/Client.js [app-rsc] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/hume/version.js [app-rsc] (ecmascript)");
const fetcherThatAddsHeaders = (fetcherToWrap)=>{
    return (args)=>{
        var _a;
        const newArgs = Object.assign({}, args);
        newArgs.headers = (_a = newArgs.headers) !== null && _a !== void 0 ? _a : {};
        newArgs.headers["X-Hume-Client-Name"] = "typescript_sdk", newArgs.headers["X-Hume-Client-Version"] = version_1.SDK_VERSION;
        return fetcherToWrap(args);
    };
};
class HumeClient {
    constructor(_options = {}){
        var _a;
        this._options = _options;
        const defaultFetcher = (_a = _options.fetcher) !== null && _a !== void 0 ? _a : core.fetcher;
        this._options.fetcher = fetcherThatAddsHeaders(defaultFetcher);
    }
    get tts() {
        var _a;
        return (_a = this._tts) !== null && _a !== void 0 ? _a : this._tts = new Client_1.Tts(this._options);
    }
    get empathicVoice() {
        var _a;
        return (_a = this._empathicVoice) !== null && _a !== void 0 ? _a : this._empathicVoice = new Client_2.EmpathicVoice(this._options);
    }
    get expressionMeasurement() {
        var _a;
        return (_a = this._expressionMeasurement) !== null && _a !== void 0 ? _a : this._expressionMeasurement = new Client_3.ExpressionMeasurement(this._options);
    }
}
exports.HumeClient = HumeClient;
}}),
"[project]/node_modules/hume/index.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
var __createBinding = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__importStar || function() {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o) {
            var ar = [];
            for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
            for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
    };
}();
var __exportStar = ("TURBOPACK member replacement", __turbopack_context__.e) && ("TURBOPACK member replacement", __turbopack_context__.e).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HumeTimeoutError = exports.HumeError = exports.HumeEnvironment = exports.Hume = void 0;
/** THIS FILE IS MANUALLY MAINAINED: see .fernignore */ exports.Hume = __importStar(__turbopack_context__.r("[project]/node_modules/hume/api/index.js [app-rsc] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/hume/wrapper/index.js [app-rsc] (ecmascript)"), exports);
var environments_1 = __turbopack_context__.r("[project]/node_modules/hume/environments.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HumeEnvironment", {
    enumerable: true,
    get: function() {
        return environments_1.HumeEnvironment;
    }
});
var errors_1 = __turbopack_context__.r("[project]/node_modules/hume/errors/index.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "HumeError", {
    enumerable: true,
    get: function() {
        return errors_1.HumeError;
    }
});
Object.defineProperty(exports, "HumeTimeoutError", {
    enumerable: true,
    get: function() {
        return errors_1.HumeTimeoutError;
    }
});
}}),

};

//# sourceMappingURL=node_modules_hume_aeedfd8d._.js.map